
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bytecodealliance/wasmtime-go/config.go (92.2%)</option>
				
				<option value="file1">github.com/bytecodealliance/wasmtime-go/engine.go (93.3%)</option>
				
				<option value="file2">github.com/bytecodealliance/wasmtime-go/error.go (30.8%)</option>
				
				<option value="file3">github.com/bytecodealliance/wasmtime-go/exporttype.go (100.0%)</option>
				
				<option value="file4">github.com/bytecodealliance/wasmtime-go/extern.go (95.1%)</option>
				
				<option value="file5">github.com/bytecodealliance/wasmtime-go/externtype.go (100.0%)</option>
				
				<option value="file6">github.com/bytecodealliance/wasmtime-go/ffi.go (100.0%)</option>
				
				<option value="file7">github.com/bytecodealliance/wasmtime-go/freelist.go (97.4%)</option>
				
				<option value="file8">github.com/bytecodealliance/wasmtime-go/func.go (98.8%)</option>
				
				<option value="file9">github.com/bytecodealliance/wasmtime-go/functype.go (97.3%)</option>
				
				<option value="file10">github.com/bytecodealliance/wasmtime-go/global.go (97.2%)</option>
				
				<option value="file11">github.com/bytecodealliance/wasmtime-go/globaltype.go (100.0%)</option>
				
				<option value="file12">github.com/bytecodealliance/wasmtime-go/importtype.go (100.0%)</option>
				
				<option value="file13">github.com/bytecodealliance/wasmtime-go/instance.go (98.3%)</option>
				
				<option value="file14">github.com/bytecodealliance/wasmtime-go/instancetype.go (70.6%)</option>
				
				<option value="file15">github.com/bytecodealliance/wasmtime-go/limits.go (80.0%)</option>
				
				<option value="file16">github.com/bytecodealliance/wasmtime-go/linker.go (95.9%)</option>
				
				<option value="file17">github.com/bytecodealliance/wasmtime-go/maybe_gc_no.go (0.0%)</option>
				
				<option value="file18">github.com/bytecodealliance/wasmtime-go/memory.go (94.9%)</option>
				
				<option value="file19">github.com/bytecodealliance/wasmtime-go/memorytype.go (100.0%)</option>
				
				<option value="file20">github.com/bytecodealliance/wasmtime-go/module.go (88.8%)</option>
				
				<option value="file21">github.com/bytecodealliance/wasmtime-go/moduletype.go (76.2%)</option>
				
				<option value="file22">github.com/bytecodealliance/wasmtime-go/slab.go (100.0%)</option>
				
				<option value="file23">github.com/bytecodealliance/wasmtime-go/store.go (96.3%)</option>
				
				<option value="file24">github.com/bytecodealliance/wasmtime-go/table.go (85.9%)</option>
				
				<option value="file25">github.com/bytecodealliance/wasmtime-go/tabletype.go (100.0%)</option>
				
				<option value="file26">github.com/bytecodealliance/wasmtime-go/trap.go (80.3%)</option>
				
				<option value="file27">github.com/bytecodealliance/wasmtime-go/val.go (90.3%)</option>
				
				<option value="file28">github.com/bytecodealliance/wasmtime-go/valtype.go (52.0%)</option>
				
				<option value="file29">github.com/bytecodealliance/wasmtime-go/wasi.go (44.2%)</option>
				
				<option value="file30">github.com/bytecodealliance/wasmtime-go/wat2wasm.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
// #include &lt;wasmtime.h&gt;
// #include &lt;stdlib.h&gt;
import "C"
import (
        "runtime"
        "unsafe"
)

// Strategy is the compilation strategies for wasmtime
type Strategy C.wasmtime_strategy_t

const (
        // StrategyAuto will let wasmtime automatically pick an appropriate compilation strategy
        StrategyAuto Strategy = C.WASMTIME_STRATEGY_AUTO
        // StrategyCranelift will force wasmtime to use the Cranelift backend
        StrategyCranelift Strategy = C.WASMTIME_STRATEGY_CRANELIFT
        // StrategyLightbeam will force wasmtime to use the lightbeam backend
        StrategyLightbeam Strategy = C.WASMTIME_STRATEGY_LIGHTBEAM
)

// OptLevel decides what degree of optimization wasmtime will perform on generated machine code
type OptLevel C.wasmtime_opt_level_t

const (
        // OptLevelNone will perform no optimizations
        OptLevelNone OptLevel = C.WASMTIME_OPT_LEVEL_NONE
        // OptLevelSpeed will optimize machine code to be as fast as possible
        OptLevelSpeed OptLevel = C.WASMTIME_OPT_LEVEL_SPEED
        // OptLevelSpeedAndSize will optimize machine code for speed, but also optimize
        // to be small, sometimes at the cost of speed.
        OptLevelSpeedAndSize OptLevel = C.WASMTIME_OPT_LEVEL_SPEED_AND_SIZE
)

// ProfilingStrategy decides what sort of profiling to enable, if any.
type ProfilingStrategy C.wasmtime_profiling_strategy_t

const (
        // ProfilingStrategyNone means no profiler will be used
        ProfilingStrategyNone ProfilingStrategy = C.WASMTIME_PROFILING_STRATEGY_NONE
        // ProfilingStrategyJitdump will use the "jitdump" linux support
        ProfilingStrategyJitdump ProfilingStrategy = C.WASMTIME_PROFILING_STRATEGY_JITDUMP
)

// Config holds options used to create an Engine and customize its behavior.
type Config struct {
        _ptr *C.wasm_config_t
}

// NewConfig creates a new `Config` with all default options configured.
func NewConfig() *Config <span class="cov8" title="1">{
        config := &amp;Config{_ptr: C.wasm_config_new()}
        runtime.SetFinalizer(config, func(config *Config) </span><span class="cov8" title="1">{
                C.wasm_config_delete(config._ptr)
        }</span>)
        <span class="cov8" title="1">return config</span>
}

// SetDebugInfo configures whether dwarf debug information for JIT code is enabled
func (cfg *Config) SetDebugInfo(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_debug_info_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetWasmThreads configures whether the wasm threads proposal is enabled
func (cfg *Config) SetWasmThreads(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_wasm_threads_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetWasmReferenceTypes configures whether the wasm reference types proposal is enabled
func (cfg *Config) SetWasmReferenceTypes(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_wasm_reference_types_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetWasmSIMD configures whether the wasm SIMD proposal is enabled
func (cfg *Config) SetWasmSIMD(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_wasm_simd_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetWasmBulkMemory configures whether the wasm bulk memory proposal is enabled
func (cfg *Config) SetWasmBulkMemory(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_wasm_bulk_memory_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetWasmMultiValue configures whether the wasm multi value proposal is enabled
func (cfg *Config) SetWasmMultiValue(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_wasm_multi_value_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetWasmModuleLinking configures whether the wasm module linking proposal is enabled
func (cfg *Config) SetWasmModuleLinking(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_wasm_module_linking_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetStrategy configures what compilation strategy is used to compile wasm code
func (cfg *Config) SetStrategy(strat Strategy) error <span class="cov8" title="1">{
        err := C.wasmtime_config_strategy_set(cfg.ptr(), C.wasmtime_strategy_t(strat))
        runtime.KeepAlive(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return mkError(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetCraneliftDebugVerifier configures whether the cranelift debug verifier will be active when
// cranelift is used to compile wasm code.
func (cfg *Config) SetCraneliftDebugVerifier(enabled bool) <span class="cov8" title="1">{
        C.wasmtime_config_cranelift_debug_verifier_set(cfg.ptr(), C.bool(enabled))
        runtime.KeepAlive(cfg)
}</span>

// SetCraneliftOptLevel configures the cranelift optimization level for generated code
func (cfg *Config) SetCraneliftOptLevel(level OptLevel) <span class="cov8" title="1">{
        C.wasmtime_config_cranelift_opt_level_set(cfg.ptr(), C.wasmtime_opt_level_t(level))
        runtime.KeepAlive(cfg)
}</span>

// SetProfiler configures what profiler strategy to use for generated code
func (cfg *Config) SetProfiler(profiler ProfilingStrategy) error <span class="cov8" title="1">{
        err := C.wasmtime_config_profiler_set(cfg.ptr(), C.wasmtime_profiling_strategy_t(profiler))
        runtime.KeepAlive(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return mkError(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CacheConfigLoadDefault enables compiled code caching for this `Config` using the default settings
// configuration can be found.
//
// For more information about caching see
// https://bytecodealliance.github.io/wasmtime/cli-cache.html
func (cfg *Config) CacheConfigLoadDefault() error <span class="cov8" title="1">{
        err := C.wasmtime_config_cache_config_load(cfg.ptr(), nil)
        runtime.KeepAlive(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return mkError(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CacheConfigLoad enables compiled code caching for this `Config` using the settings specified
// in the configuration file `path`.
//
// For more information about caching and configuration options see
// https://bytecodealliance.github.io/wasmtime/cli-cache.html
func (cfg *Config) CacheConfigLoad(path string) error <span class="cov8" title="1">{
        cstr := C.CString(path)
        err := C.wasmtime_config_cache_config_load(cfg.ptr(), cstr)
        C.free(unsafe.Pointer(cstr))
        runtime.KeepAlive(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return mkError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetInterruptable configures whether generated wasm code can be interrupted via interrupt
// handles.
func (cfg *Config) SetInterruptable(interruptable bool) <span class="cov8" title="1">{
        C.wasmtime_config_interruptable_set(cfg.ptr(), C.bool(interruptable))
        runtime.KeepAlive(cfg)
}</span>

// See comments in `ffi.go` for what's going on here
func (cfg *Config) ptr() *C.wasm_config_t <span class="cov8" title="1">{
        ret := cfg._ptr
        maybeGC()
        if ret == nil </span><span class="cov8" title="1">{
                panic("Config has already been used up")</span>
        }
        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// Engine is an instance of a wasmtime engine which is used to create a `Store`.
//
// Engines are a form of global configuration for wasm compilations and modules
// and such.
type Engine struct {
        _ptr *C.wasm_engine_t
}

// NewEngine creates a new `Engine` with default configuration.
func NewEngine() *Engine <span class="cov8" title="1">{
        engine := &amp;Engine{_ptr: C.wasm_engine_new()}
        runtime.SetFinalizer(engine, func(engine *Engine) </span><span class="cov8" title="1">{
                C.wasm_engine_delete(engine._ptr)
        }</span>)
        <span class="cov8" title="1">return engine</span>
}

// NewEngineWithConfig creates a new `Engine` with the `Config` provided
//
// Note that once a `Config` is passed to this method it cannot be used again.
func NewEngineWithConfig(config *Config) *Engine <span class="cov8" title="1">{
        if config.ptr() == nil </span><span class="cov0" title="0">{
                panic("config already used")</span>
        }
        <span class="cov8" title="1">engine := &amp;Engine{_ptr: C.wasm_engine_new_with_config(config.ptr())}
        runtime.SetFinalizer(config, nil)
        config._ptr = nil
        runtime.SetFinalizer(engine, func(engine *Engine) </span><span class="cov8" title="1">{
                C.wasm_engine_delete(engine._ptr)
        }</span>)
        <span class="cov8" title="1">return engine</span>
}

func (engine *Engine) ptr() *C.wasm_engine_t <span class="cov8" title="1">{
        ret := engine._ptr
        maybeGC()
        return ret
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
import "C"
import "runtime"

type Error struct {
        _ptr *C.wasmtime_error_t
}

func mkError(ptr *C.wasmtime_error_t) *Error <span class="cov8" title="1">{
        err := &amp;Error{_ptr: ptr}
        runtime.SetFinalizer(err, func(err *Error) </span><span class="cov8" title="1">{
                C.wasmtime_error_delete(err._ptr)
        }</span>)
        <span class="cov8" title="1">return err</span>
}

func (e *Error) ptr() *C.wasmtime_error_t <span class="cov0" title="0">{
        ret := e._ptr
        maybeGC()
        return ret
}</span>

func (e *Error) Error() string <span class="cov0" title="0">{
        message := C.wasm_byte_vec_t{}
        C.wasmtime_error_message(e.ptr(), &amp;message)
        ret := C.GoStringN(message.data, C.int(message.size))
        runtime.KeepAlive(e)
        C.wasm_byte_vec_delete(&amp;message)
        return ret
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// ExportType is one of the exports component.
// A module defines a set of exports that become accessible to the host environment once the module has been instantiated.
type ExportType struct {
        _ptr   *C.wasm_exporttype_t
        _owner interface{}
}

// NewExportType creates a new `ExportType` with the `name` and the type provided.
func NewExportType(name string, ty AsExternType) *ExportType <span class="cov8" title="1">{
        nameVec := stringToByteVec(name)

        // Creating an export type requires taking ownership, so create a copy
        // so we don't have to invalidate pointers here. Shouldn't be too
        // costly in theory anyway.
        extern := ty.AsExternType()
        ptr := C.wasm_externtype_copy(extern.ptr())
        runtime.KeepAlive(extern)

        // And once we've got all that create the export type!
        exportPtr := C.wasm_exporttype_new(&amp;nameVec, ptr)

        return mkExportType(exportPtr, nil)
}</span>

func mkExportType(ptr *C.wasm_exporttype_t, owner interface{}) *ExportType <span class="cov8" title="1">{
        exporttype := &amp;ExportType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(exporttype, func(exporttype *ExportType) </span><span class="cov8" title="1">{
                        C.wasm_exporttype_delete(exporttype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return exporttype</span>
}

func (ty *ExportType) ptr() *C.wasm_exporttype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *ExportType) owner() interface{} <span class="cov8" title="1">{
        if ty._owner != nil </span><span class="cov8" title="1">{
                return ty._owner
        }</span>
        <span class="cov8" title="1">return ty</span>
}

// Name returns the name in the module this export type is exporting
func (ty *ExportType) Name() string <span class="cov8" title="1">{
        ptr := C.wasm_exporttype_name(ty.ptr())
        ret := C.GoStringN(ptr.data, C.int(ptr.size))
        runtime.KeepAlive(ty)
        return ret
}</span>

// Type returns the type of item this export type expects
func (ty *ExportType) Type() *ExternType <span class="cov8" title="1">{
        ptr := C.wasm_exporttype_type(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
import "C"
import "runtime"

// Extern is an external value, which is the runtime representation of an entity that can be imported or exported.
// It is an address denoting either a function instance, table instance, memory instance, or global instances in the shared store.
// Read more in [spec](https://webassembly.github.io/spec/core/exec/runtime.html#external-values)
//
type Extern struct {
        _ptr     *C.wasm_extern_t
        _owner   interface{}
        freelist *freeList
}

// AsExtern is an interface for all types which can be imported or exported as an Extern
type AsExtern interface {
        AsExtern() *Extern
}

func mkExtern(ptr *C.wasm_extern_t, freelist *freeList, owner interface{}) *Extern <span class="cov8" title="1">{
        f := &amp;Extern{_ptr: ptr, _owner: owner, freelist: freelist}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(f, func(f *Extern) </span><span class="cov8" title="1">{
                        f.freelist.lock.Lock()
                        defer f.freelist.lock.Unlock()
                        f.freelist.externs = append(f.freelist.externs, f._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return f</span>
}

func (e *Extern) ptr() *C.wasm_extern_t <span class="cov8" title="1">{
        ret := e._ptr
        maybeGC()
        return ret
}</span>

func (e *Extern) owner() interface{} <span class="cov8" title="1">{
        if e._owner != nil </span><span class="cov8" title="1">{
                return e._owner
        }</span>
        <span class="cov8" title="1">return e</span>
}

// Type returns the type of this export
func (e *Extern) Type() *ExternType <span class="cov8" title="1">{
        ptr := C.wasm_extern_type(e.ptr())
        runtime.KeepAlive(e)
        return mkExternType(ptr, nil)
}</span>

// Func returns a Func if this export is a function or nil otherwise
func (e *Extern) Func() *Func <span class="cov8" title="1">{
        ret := C.wasm_extern_as_func(e.ptr())
        if ret == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkFunc(ret, e.freelist, e.owner())</span>
}

// Global returns a Global if this export is a global or nil otherwise
func (e *Extern) Global() *Global <span class="cov8" title="1">{
        ret := C.wasm_extern_as_global(e.ptr())
        if ret == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkGlobal(ret, e.freelist, e.owner())</span>
}

// Memory returns a Memory if this export is a memory or nil otherwise
func (e *Extern) Memory() *Memory <span class="cov8" title="1">{
        ret := C.wasm_extern_as_memory(e.ptr())
        if ret == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkMemory(ret, e.freelist, e.owner())</span>
}

// Table returns a Table if this export is a table or nil otherwise
func (e *Extern) Table() *Table <span class="cov8" title="1">{
        ret := C.wasm_extern_as_table(e.ptr())
        if ret == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkTable(ret, e.freelist, e.owner())</span>
}

// Module returns a Module if this export is a module or nil otherwise
func (e *Extern) Module() *Module <span class="cov8" title="1">{
        ret := C.wasm_extern_as_module(e.ptr())
        if ret == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkModule(ret, e.owner())</span>
}

// Instance returns a Instance if this export is a module or nil otherwise
func (e *Extern) Instance() *Instance <span class="cov8" title="1">{
        ret := C.wasm_extern_as_instance(e.ptr())
        if ret == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkInstance(ret, e.freelist, e.owner())</span>
}

func (e *Extern) AsExtern() *Extern <span class="cov8" title="1">{
        return e
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// ExternType means one of external types which classify imports and external values with their respective types.
type ExternType struct {
        _ptr   *C.wasm_externtype_t
        _owner interface{}
}

// AsExternType is an interface for all types which can be ExternType.
type AsExternType interface {
        AsExternType() *ExternType
}

func mkExternType(ptr *C.wasm_externtype_t, owner interface{}) *ExternType <span class="cov8" title="1">{
        externtype := &amp;ExternType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(externtype, func(externtype *ExternType) </span><span class="cov8" title="1">{
                        C.wasm_externtype_delete(externtype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return externtype</span>
}

func (ty *ExternType) ptr() *C.wasm_externtype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *ExternType) owner() interface{} <span class="cov8" title="1">{
        if ty._owner != nil </span><span class="cov8" title="1">{
                return ty._owner
        }</span>
        <span class="cov8" title="1">return ty</span>
}

// FuncType returns the underlying `FuncType` for this `ExternType` if it's a function
// type. Otherwise returns `nil`.
func (ty *ExternType) FuncType() *FuncType <span class="cov8" title="1">{
        ptr := C.wasm_externtype_as_functype(ty.ptr())
        if ptr == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return mkFuncType(ptr, ty.owner())</span>
}

// GlobalType returns the underlying `GlobalType` for this `ExternType` if it's a *global* type.
// Otherwise returns `nil`.
func (ty *ExternType) GlobalType() *GlobalType <span class="cov8" title="1">{
        ptr := C.wasm_externtype_as_globaltype(ty.ptr())
        if ptr == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return mkGlobalType(ptr, ty.owner())</span>
}

// TableType returns the underlying `TableType` for this `ExternType` if it's a *table* type.
// Otherwise returns `nil`.
func (ty *ExternType) TableType() *TableType <span class="cov8" title="1">{
        ptr := C.wasm_externtype_as_tabletype(ty.ptr())
        if ptr == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return mkTableType(ptr, ty.owner())</span>
}

// MemoryType returns the underlying `MemoryType` for this `ExternType` if it's a *memory* type.
// Otherwise returns `nil`.
func (ty *ExternType) MemoryType() *MemoryType <span class="cov8" title="1">{
        ptr := C.wasm_externtype_as_memorytype(ty.ptr())
        if ptr == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return mkMemoryType(ptr, ty.owner())</span>
}

// AsExternType returns this type itself
func (ty *ExternType) AsExternType() *ExternType <span class="cov8" title="1">{
        return ty
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package wasmtime

// #cgo CFLAGS:-I${SRCDIR}/build/include
// #cgo !windows LDFLAGS:-lwasmtime -lm -ldl
// #cgo windows CFLAGS:-DWASM_API_EXTERN= -DWASI_API_EXTERN=
// #cgo windows LDFLAGS:-lwasmtime -luserenv -lole32 -lntdll -lws2_32 -lkernel32 -lbcrypt
// #cgo linux,amd64 LDFLAGS:-L${SRCDIR}/build/linux-x86_64
// #cgo darwin,amd64 LDFLAGS:-L${SRCDIR}/build/macos-x86_64
// #cgo windows,amd64 LDFLAGS:-L${SRCDIR}/build/windows-x86_64
// #include &lt;wasm.h&gt;
import "C"
import "runtime"
import "unsafe"

// # What's up with `ptr()` methods?
//
// We use `runtime.SetFinalizer` to free all objects we allocate from C. This
// is intended to make usage of the API much simpler since you don't have to
// close/free anything. The tricky part here though is laid out in
// `runtime.SetFinalizer`'s documentation which is that if you read a
// non-gc-value (like a C pointer) from a GC object then after the value is
// read the GC value might get garbage collected. This is quite bad for us
// because the garbage collection will free the C pointer, making the C pointer
// actually invalid.
//
// The solution is to add `runtime.KeepAlive` calls after C function calls to
// ensure that the GC object lives at least as long as the C function call
// itself. This is naturally quite error-prone, so the goal here with `ptr()`
// methods is to make us a bit more resilient to these sorts of errors and
// expose segfaults during development.
//
// Each `ptr()` method has the basic structure of doing these steps:
//
// 1. First it reads the pointer value from the GC object
// 2. Next it conditionally calls `runtime.GC()`, depending on build flags
// 3. Finally it returns the original pointer value
//
// The goal here is to as aggressively as we can collect GC objects when
// testing and trigger finalizers as frequently as we can. This naturally
// slows things down quite a bit, so conditional compilation (with the `debug`
// tag) is used to enable this. Our CI runs tests with `-tag debug` to make
// sure this is at least run somewhere.
//
// If anyone else has a better idea of what to handle all this it would be very
// much appreciated :)

// Convert a Go string into an owned `wasm_byte_vec_t`
func stringToByteVec(s string) C.wasm_byte_vec_t <span class="cov8" title="1">{
        vec := C.wasm_byte_vec_t{}
        C.wasm_byte_vec_new_uninitialized(&amp;vec, C.size_t(len(s)))
        C.memcpy(unsafe.Pointer(vec.data), unsafe.Pointer(C._GoStringPtr(s)), vec.size)
        runtime.KeepAlive(s)
        return vec
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package wasmtime

// #include &lt;wasi.h&gt;
// #include &lt;wasmtime.h&gt;
import "C"
import (
        "runtime"
        "sync"
)

// A structure used to defer deletion of C API objects to the main thread.
//
// The C API is not threadsafe and objects must be destroyed on the original
// thread that they came from. We also, however, want to use `SetFinalizer` to
// free objects because it's vastly more convenient than explicit free
// methods. The `SetFinalizer` routine will spin up a goroutine for finalizers
// that might run concurrently, however. To fix this we use this structure to
// collect pointers which need to be free'd.
//
// When a `SetFinalizer` finalizer runs it will enqueue a pointer inside of
// this freelist. This list is then periodically checked to clear out any
// pointers on the main thread with the store. Pointers contained here are
// basically those all connected to a `wasm_store_t`.
//
// This isn't really a great solution but at this time I can't really think
// of anything else unfortunately. I'm hoping that we can continue to optimize
// this over time if necessary, but otherwise this should at least fix crashes
// seen on CI and ensure that everything is free'd correctly.
type freeList struct {
        // The freelist can be modified from both the main thread with a store
        // and from finalizers, so because that can happen concurrently we
        // protect the arrays below with a lock.
        lock sync.Mutex

        // All the various kinds of pointers that we'll store to get deallocated
        // here.

        stores        []*C.wasm_store_t
        memories      []*C.wasm_memory_t
        funcs         []*C.wasm_func_t
        tables        []*C.wasm_table_t
        globals       []*C.wasm_global_t
        instances     []*C.wasm_instance_t
        externs       []*C.wasm_extern_t
        linkers       []*C.wasmtime_linker_t
        wasiInstances []*C.wasi_instance_t
        externVecs    []*C.wasm_extern_vec_t
        vals          []*C.wasm_val_t
}

func newFreeList() *freeList <span class="cov8" title="1">{
        // freelists have their own finalizer which clears out all the contents
        // once the freelist itself has gone away. If this happens that should
        // be safe to do because no other live objects have access to the
        // freelist, so whatever thread is running the freelist is "the thread
        // which own things" so it's safe to clear everything out, we know that
        // no other concurrent accesses will be happening.
        ret := &amp;freeList{}
        runtime.SetFinalizer(ret, func(f *freeList) </span><span class="cov8" title="1">{ f.clear() }</span>)
        <span class="cov8" title="1">return ret</span>
}

// Clears out this freelist, actually deleting all pointers that are contained
// within it.
func (f *freeList) clear() <span class="cov8" title="1">{
        f.lock.Lock()
        defer f.lock.Unlock()

        for _, p := range f.memories </span><span class="cov8" title="1">{
                C.wasm_memory_delete(p)
        }</span>
        <span class="cov8" title="1">f.memories = nil

        for _, p := range f.stores </span><span class="cov8" title="1">{
                C.wasm_store_delete(p)
        }</span>
        <span class="cov8" title="1">f.stores = nil

        for _, p := range f.funcs </span><span class="cov8" title="1">{
                C.wasm_func_delete(p)
        }</span>
        <span class="cov8" title="1">f.funcs = nil

        for _, p := range f.tables </span><span class="cov8" title="1">{
                C.wasm_table_delete(p)
        }</span>
        <span class="cov8" title="1">f.tables = nil

        for _, p := range f.globals </span><span class="cov8" title="1">{
                C.wasm_global_delete(p)
        }</span>
        <span class="cov8" title="1">f.globals = nil

        for _, p := range f.instances </span><span class="cov8" title="1">{
                C.wasm_instance_delete(p)
        }</span>
        <span class="cov8" title="1">f.instances = nil

        for _, p := range f.externs </span><span class="cov8" title="1">{
                C.wasm_extern_delete(p)
        }</span>
        <span class="cov8" title="1">f.externs = nil

        for _, p := range f.linkers </span><span class="cov8" title="1">{
                C.wasmtime_linker_delete(p)
        }</span>
        <span class="cov8" title="1">f.linkers = nil

        for _, p := range f.wasiInstances </span><span class="cov0" title="0">{
                C.wasi_instance_delete(p)
        }</span>
        <span class="cov8" title="1">f.wasiInstances = nil

        for _, p := range f.externVecs </span><span class="cov8" title="1">{
                C.wasm_extern_vec_delete(p)
        }</span>
        <span class="cov8" title="1">f.externVecs = nil

        for _, p := range f.vals </span><span class="cov8" title="1">{
                C.wasm_val_delete(p)
        }</span>
        <span class="cov8" title="1">f.vals = nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package wasmtime

// #include "shims.h"
import "C"
import (
        "errors"
        "reflect"
        "runtime"
        "sync"
        "unsafe"
)

// Func is a function instance, which is the runtime representation of a function.
// It effectively is a closure of the original function over the runtime module instance of its originating module.
// The module instance is used to resolve references to other definitions during execution of the function.
// Read more in [spec](https://webassembly.github.io/spec/core/exec/runtime.html#function-instances)
type Func struct {
        _ptr     *C.wasm_func_t
        _owner   interface{}
        freelist *freeList
}

// TODO
type Caller struct {
        ptr      *C.wasmtime_caller_t
        freelist *freeList
}

// Note that `newMapEntry` and `wrapMapEntry` here need to be careful to not
// close over any state that can retain the `freelist` or other wasmtime
// objects. Otherwise that'll create a cycle between the Rust and Go heaps
// which can't be garbage collected.
type newMapEntry struct {
        callback  func(*Caller, []Val) ([]Val, *Trap)
        results   []*ValType
        caller_id C.size_t
}

type wrapMapEntry struct {
        callback  reflect.Value
        caller_id C.size_t
}

type callerState struct {
        freelist  *freeList
        lastPanic interface{}
        cnt       uint
}

var gLock sync.Mutex
var gNewMap = make(map[int]newMapEntry)
var gNewMapSlab slab
var gWrapMap = make(map[int]wrapMapEntry)
var gWrapMapSlab slab
var gCallerState = make(map[C.size_t]*callerState)

// NewFunc creates a new `Func` with the given `ty` which, when called, will call `f`
//
// The `ty` given is the wasm type signature of the `Func` to create. When called
// the `f` callback receives two arguments. The first is a `Caller` to learn
// information about the calling context and the second is a list of arguments
// represented as a `Val`. The parameters are guaranteed to match the parameters
// types specified in `ty`.
//
// The `f` callback is expected to produce one of two values. Results can be
// returned as an array of `[]Val`. The number and types of these results much
// match the `ty` given, otherwise the program will panic. The `f` callback can
// also produce a trap which will trigger trap unwinding in wasm, and the trap
// will be returned to the original caller.
//
// If the `f` callback panics then the panic will be propagated to the caller
// as well.
func NewFunc(
        store *Store,
        ty *FuncType,
        f func(*Caller, []Val) ([]Val, *Trap),
) *Func <span class="cov8" title="1">{
        gLock.Lock()
        idx := gNewMapSlab.allocate()
        gNewMap[idx] = newMapEntry{
                callback:  f,
                results:   ty.Results(),
                caller_id: C.size_t(uintptr(unsafe.Pointer(store.freelist))),
        }
        gLock.Unlock()

        ptr := C.c_func_new_with_env(
                store.ptr(),
                ty.ptr(),
                C.size_t(idx),
                0,
        )
        runtime.KeepAlive(store)
        runtime.KeepAlive(ty)

        return mkFunc(ptr, store.freelist, nil)
}</span>

//export goTrampolineNew
func goTrampolineNew(
        callerPtr *C.wasmtime_caller_t,
        env C.size_t,
        argsPtr *C.wasm_val_vec_t,
        resultsPtr *C.wasm_val_vec_t,
) *C.wasm_trap_t <span class="cov8" title="1">{
        idx := int(env)
        gLock.Lock()
        entry := gNewMap[idx]
        caller_id := entry.caller_id
        freelist := gCallerState[caller_id].freelist
        gLock.Unlock()

        caller := &amp;Caller{ptr: callerPtr, freelist: freelist}
        defer func() </span><span class="cov8" title="1">{ caller.ptr = nil }</span>()

        <span class="cov8" title="1">params := make([]Val, int(argsPtr.size))
        var val C.wasm_val_t
        base := unsafe.Pointer(argsPtr.data)
        for i := 0; i &lt; len(params); i++ </span><span class="cov8" title="1">{
                ptr := (*C.wasm_val_t)(unsafe.Pointer(uintptr(base) + uintptr(i)*unsafe.Sizeof(val)))
                params[i] = mkVal(ptr, freelist)
        }</span>

        <span class="cov8" title="1">var results []Val
        var trap *Trap
        var lastPanic interface{}
        func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{ lastPanic = recover() }</span>()
                <span class="cov8" title="1">results, trap = entry.callback(caller, params)
                if trap != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if len(results) != len(entry.results) </span><span class="cov8" title="1">{
                        panic("callback didn't produce the correct number of results")</span>
                }
                <span class="cov8" title="1">for i, ty := range entry.results </span><span class="cov8" title="1">{
                        if results[i].Kind() != ty.Kind() </span><span class="cov8" title="1">{
                                panic("callback produced wrong type of result")</span>
                        }
                }
        }()
        <span class="cov8" title="1">if trap == nil &amp;&amp; lastPanic != nil </span><span class="cov8" title="1">{
                gLock.Lock()
                gCallerState[caller_id].lastPanic = lastPanic
                gLock.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">if trap != nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(trap, nil)
                return trap.ptr()
        }</span>

        <span class="cov8" title="1">base = unsafe.Pointer(resultsPtr.data)
        for i := 0; i &lt; len(results); i++ </span><span class="cov8" title="1">{
                ptr := (*C.wasm_val_t)(unsafe.Pointer(uintptr(base) + uintptr(i)*unsafe.Sizeof(val)))
                C.wasm_val_copy(ptr, results[i].ptr())
        }</span>
        <span class="cov8" title="1">runtime.KeepAlive(results)
        return nil</span>
}

//export goFinalizeNew
func goFinalizeNew(env unsafe.Pointer) <span class="cov8" title="1">{
        idx := int(uintptr(env))
        gLock.Lock()
        defer gLock.Unlock()
        delete(gNewMap, idx)
        gNewMapSlab.deallocate(idx)
}</span>

// WrapFunc wraps a native Go function, `f`, as a wasm `Func`.
//
// This function differs from `NewFunc` in that it will determine the type
// signature of the wasm function given the input value `f`. The `f` value
// provided must be a Go function. It may take any number of the following
// types as arguments:
//
// `int32` - a wasm `i32`
//
// `int64` - a wasm `i64`
//
// `float32` - a wasm `f32`
//
// `float64` - a wasm `f32`
//
// `*Caller` - information about the caller's instance
//
// `*Func` - a wasm `funcref`
//
// anything else - a wasm `externref`
//
// The Go function may return any number of values. It can return any number of
// primitive wasm values (integers/floats), and the last return value may
// optionally be `*Trap`. If a `*Trap` returned is `nil` then the other values
// are returned from the wasm function. Otherwise the `*Trap` is returned and
// it's considered as if the host function trapped.
//
// If the function `f` panics then the panic will be propagated to the caller.
func WrapFunc(
        store *Store,
        f interface{},
) *Func <span class="cov8" title="1">{
        // Make sure the `interface{}` passed in was indeed a function
        val := reflect.ValueOf(f)
        ty := val.Type()
        if ty.Kind() != reflect.Func </span><span class="cov8" title="1">{
                panic("callback provided must be a `func`")</span>
        }

        // infer the parameter types, and `*Caller` type is special in the
        // parameters so be sure to case on that as well.
        <span class="cov8" title="1">params := make([]*ValType, 0, ty.NumIn())
        var caller *Caller
        for i := 0; i &lt; ty.NumIn(); i++ </span><span class="cov8" title="1">{
                paramTy := ty.In(i)
                if paramTy != reflect.TypeOf(caller) </span><span class="cov8" title="1">{
                        params = append(params, typeToValType(paramTy))
                }</span>
        }

        // Then infer the result types, where a final `*Trap` result value is
        // also special.
        <span class="cov8" title="1">results := make([]*ValType, 0, ty.NumOut())
        var trap *Trap
        for i := 0; i &lt; ty.NumOut(); i++ </span><span class="cov8" title="1">{
                resultTy := ty.Out(i)
                if i == ty.NumOut()-1 &amp;&amp; resultTy == reflect.TypeOf(trap) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">results = append(results, typeToValType(resultTy))</span>
        }
        <span class="cov8" title="1">wasmTy := NewFuncType(params, results)

        // Store our `f` callback into the slab for wrapped functions, and now
        // we've got everything necessary to make thw asm handle.
        gLock.Lock()
        idx := gWrapMapSlab.allocate()
        gWrapMap[idx] = wrapMapEntry{
                callback:  val,
                caller_id: C.size_t(uintptr(unsafe.Pointer(store.freelist))),
        }
        gLock.Unlock()

        ptr := C.c_func_new_with_env(
                store.ptr(),
                wasmTy.ptr(),
                C.size_t(idx),
                1, // this is `WrapFunc`, not `NewFunc`
        )
        runtime.KeepAlive(store)
        runtime.KeepAlive(wasmTy)
        return mkFunc(ptr, store.freelist, nil)</span>
}

func typeToValType(ty reflect.Type) *ValType <span class="cov8" title="1">{
        var a int32
        if ty == reflect.TypeOf(a) </span><span class="cov8" title="1">{
                return NewValType(KindI32)
        }</span>
        <span class="cov8" title="1">var b int64
        if ty == reflect.TypeOf(b) </span><span class="cov8" title="1">{
                return NewValType(KindI64)
        }</span>
        <span class="cov8" title="1">var c float32
        if ty == reflect.TypeOf(c) </span><span class="cov8" title="1">{
                return NewValType(KindF32)
        }</span>
        <span class="cov8" title="1">var d float64
        if ty == reflect.TypeOf(d) </span><span class="cov8" title="1">{
                return NewValType(KindF64)
        }</span>
        <span class="cov8" title="1">var f *Func
        if ty == reflect.TypeOf(f) </span><span class="cov8" title="1">{
                return NewValType(KindFuncref)
        }</span>
        <span class="cov8" title="1">return NewValType(KindExternref)</span>
}

//export goTrampolineWrap
func goTrampolineWrap(
        callerPtr *C.wasmtime_caller_t,
        env C.size_t,
        argsPtr *C.wasm_val_vec_t,
        resultsPtr *C.wasm_val_vec_t,
) *C.wasm_trap_t <span class="cov8" title="1">{
        // Convert all our parameters to `[]reflect.Value`, taking special care
        // for `*Caller` but otherwise reading everything through `Val`.
        idx := int(env)
        gLock.Lock()
        entry := gWrapMap[idx]
        caller_id := entry.caller_id
        freelist := gCallerState[caller_id].freelist
        gLock.Unlock()

        // Wrap our `Caller` argument in case it's needed
        caller := &amp;Caller{ptr: callerPtr, freelist: freelist}
        defer func() </span><span class="cov8" title="1">{ caller.ptr = nil }</span>()

        <span class="cov8" title="1">ty := entry.callback.Type()
        params := make([]reflect.Value, ty.NumIn())
        base := unsafe.Pointer(argsPtr.data)
        var raw C.wasm_val_t
        for i := 0; i &lt; len(params); i++ </span><span class="cov8" title="1">{
                if ty.In(i) == reflect.TypeOf(caller) </span><span class="cov8" title="1">{
                        params[i] = reflect.ValueOf(caller)
                }</span> else<span class="cov8" title="1"> {
                        ptr := (*C.wasm_val_t)(base)
                        val := mkVal(ptr, freelist)
                        params[i] = reflect.ValueOf(val.Get())
                        base = unsafe.Pointer(uintptr(base) + unsafe.Sizeof(raw))
                }</span>
        }

        // Invoke the function, catching any panics to propagate later. Panics
        // result in immediately returning a trap.
        <span class="cov8" title="1">var results []reflect.Value
        var lastPanic interface{}
        func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{ lastPanic = recover() }</span>()
                <span class="cov8" title="1">results = entry.callback.Call(params)</span>
        }()
        <span class="cov8" title="1">if lastPanic != nil </span><span class="cov8" title="1">{
                gLock.Lock()
                gCallerState[caller_id].lastPanic = lastPanic
                gLock.Unlock()
                return nil
        }</span>

        // And now we write all the results into memory depending on the type
        // of value that was returned.
        <span class="cov8" title="1">base = unsafe.Pointer(resultsPtr.data)
        for _, result := range results </span><span class="cov8" title="1">{
                ptr := (*C.wasm_val_t)(base)
                switch val := result.Interface().(type) </span>{
                case int32:<span class="cov8" title="1">
                        *ptr = *ValI32(val).ptr()</span>
                case int64:<span class="cov8" title="1">
                        *ptr = *ValI64(val).ptr()</span>
                case float32:<span class="cov8" title="1">
                        *ptr = *ValF32(val).ptr()</span>
                case float64:<span class="cov8" title="1">
                        *ptr = *ValF64(val).ptr()</span>
                case *Func:<span class="cov8" title="1">
                        raw := ValFuncref(val)
                        C.wasm_val_copy(ptr, raw.ptr())
                        runtime.KeepAlive(raw)</span>
                case *Trap:<span class="cov8" title="1">
                        if val != nil </span><span class="cov8" title="1">{
                                runtime.SetFinalizer(val, nil)
                                return val.ptr()
                        }</span>
                default:<span class="cov8" title="1">
                        raw := ValExternref(val)
                        C.wasm_val_copy(ptr, raw.ptr())
                        runtime.KeepAlive(raw)</span>
                }
                <span class="cov8" title="1">base = unsafe.Pointer(uintptr(base) + unsafe.Sizeof(raw))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

//export goFinalizeWrap
func goFinalizeWrap(env unsafe.Pointer) <span class="cov8" title="1">{
        idx := int(uintptr(env))
        gLock.Lock()
        defer gLock.Unlock()
        delete(gWrapMap, idx)
        gWrapMapSlab.deallocate(idx)
}</span>

func mkFunc(ptr *C.wasm_func_t, freelist *freeList, owner interface{}) *Func <span class="cov8" title="1">{
        f := &amp;Func{_ptr: ptr, _owner: owner, freelist: freelist}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(f, func(f *Func) </span><span class="cov8" title="1">{
                        f.freelist.lock.Lock()
                        defer f.freelist.lock.Unlock()
                        f.freelist.funcs = append(f.freelist.funcs, f._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return f</span>
}

func (f *Func) ptr() *C.wasm_func_t <span class="cov8" title="1">{
        f.freelist.clear()
        ret := f._ptr
        maybeGC()
        return ret
}</span>

func (f *Func) owner() interface{} <span class="cov8" title="1">{
        if f._owner != nil </span><span class="cov0" title="0">{
                return f._owner
        }</span>
        <span class="cov8" title="1">return f</span>
}

// Type returns the type of this func
func (f *Func) Type() *FuncType <span class="cov8" title="1">{
        ptr := C.wasm_func_type(f.ptr())
        runtime.KeepAlive(f)
        return mkFuncType(ptr, nil)
}</span>

// ParamArity returns the numer of parameters this function expects
func (f *Func) ParamArity() int <span class="cov8" title="1">{
        ret := C.wasm_func_param_arity(f.ptr())
        runtime.KeepAlive(f)
        return int(ret)
}</span>

// ResultArity returns the numer of results this function produces
func (f *Func) ResultArity() int <span class="cov8" title="1">{
        ret := C.wasm_func_result_arity(f.ptr())
        runtime.KeepAlive(f)
        return int(ret)
}</span>

// Call invokes this function with the provided `args`.
//
// This variadic function must be invoked with the correct number and type of
// `args` as specified by the type of this function. This property is checked
// at runtime. Each `args` may have one of the following types:
//
// `int32` - a wasm `i32`
//
// `int64` - a wasm `i64`
//
// `float32` - a wasm `f32`
//
// `float64` - a wasm `f64`
//
// `Val` - correspond to a wasm value
//
// `*Func` - a wasm `funcref`
//
// anything else - a wasm `externref`
//
// This function will have one of three results:
//
// 1. If the function returns successfully, then the `interface{}` return
// argument will be the result of the function. If there were 0 results then
// this value is `nil`. If there was one result then this is that result.
// Otherwise if there were multiple results then `[]Val` is returned.
//
// 2. If this function invocation traps, then the returned `interface{}` value
// will be `nil` and a non-`nil` `*Trap` will be returned with information
// about the trap that happened.
//
// 3. If a panic in Go ends up happening somewhere, then this function will
// panic.
func (f *Func) Call(args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        params := f.Type().Params()
        if len(args) &gt; len(params) </span><span class="cov8" title="1">{
                return nil, errors.New("too many arguments provided")
        }</span>
        <span class="cov8" title="1">paramsVec := C.wasm_val_vec_t{}
        C.wasm_val_vec_new_uninitialized(&amp;paramsVec, C.size_t(len(args)))
        for i, param := range args </span><span class="cov8" title="1">{
                var rawVal Val
                switch val := param.(type) </span>{
                case int:<span class="cov8" title="1">
                        switch params[i].Kind() </span>{
                        case KindI32:<span class="cov8" title="1">
                                rawVal = ValI32(int32(val))</span>
                        case KindI64:<span class="cov8" title="1">
                                rawVal = ValI64(int64(val))</span>
                        default:<span class="cov8" title="1">
                                return nil, errors.New("integer provided for non-integer argument")</span>
                        }
                case int32:<span class="cov8" title="1">
                        rawVal = ValI32(val)</span>
                case int64:<span class="cov8" title="1">
                        rawVal = ValI64(val)</span>
                case float32:<span class="cov8" title="1">
                        rawVal = ValF32(val)</span>
                case float64:<span class="cov8" title="1">
                        rawVal = ValF64(val)</span>
                case *Func:<span class="cov8" title="1">
                        rawVal = ValFuncref(val)</span>
                case Val:<span class="cov8" title="1">
                        rawVal = val</span>

                default:<span class="cov8" title="1">
                        rawVal = ValExternref(val)</span>
                }

                <span class="cov8" title="1">base := unsafe.Pointer(paramsVec.data)
                ptr := rawVal.ptr()
                C.wasm_val_copy(
                        (*C.wasm_val_t)(unsafe.Pointer(uintptr(base)+unsafe.Sizeof(*ptr)*uintptr(i))),
                        ptr,
                )
                runtime.KeepAlive(rawVal)</span>
        }

        <span class="cov8" title="1">resultsVec := C.wasm_val_vec_t{}
        C.wasm_val_vec_new_uninitialized(&amp;resultsVec, C.size_t(f.ResultArity()))

        var err *C.wasmtime_error_t
        trap := enterWasm(f.freelist, func(trap **C.wasm_trap_t) </span><span class="cov8" title="1">{
                err = C.go_wasmtime_func_call(
                        f.ptr(),
                        &amp;paramsVec,
                        &amp;resultsVec,
                        trap,
                )
        }</span>)
        <span class="cov8" title="1">runtime.KeepAlive(f)
        runtime.KeepAlive(args)
        C.wasm_val_vec_delete(&amp;paramsVec)

        if trap != nil </span><span class="cov8" title="1">{
                return nil, trap
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, mkError(err)
        }</span>

        <span class="cov8" title="1">if resultsVec.size == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span> else<span class="cov8" title="1"> if resultsVec.size == 1 </span><span class="cov8" title="1">{
                ret := mkVal(resultsVec.data, f.freelist).Get()
                C.wasm_val_vec_delete(&amp;resultsVec)
                return ret, nil
        }</span> else<span class="cov8" title="1"> {
                results := make([]Val, int(resultsVec.size))
                base := unsafe.Pointer(resultsVec.data)
                var val C.wasm_val_t
                for i := 0; i &lt; int(resultsVec.size); i++ </span><span class="cov8" title="1">{
                        ptr := (*C.wasm_val_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(val)*uintptr(i)))
                        results[i] = mkVal(ptr, f.freelist)
                }</span>
                <span class="cov8" title="1">C.wasm_val_vec_delete(&amp;resultsVec)
                return results, nil</span>
        }

}

func (f *Func) AsExtern() *Extern <span class="cov8" title="1">{
        ptr := C.wasm_func_as_extern(f.ptr())
        return mkExtern(ptr, f.freelist, f.owner())
}</span>

// GetExport gets an exported item from the caller's module.
//
// May return `nil` if the export doesn't, if it's not a memory, if there isn't
// a caller, etc.
func (c *Caller) GetExport(name string) *Extern <span class="cov8" title="1">{
        if c.ptr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ptr := C.go_caller_export_get(
                c.ptr,
                C._GoStringPtr(name),
                C._GoStringLen(name),
        )
        runtime.KeepAlive(name)
        runtime.KeepAlive(c)
        if ptr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkExtern(ptr, c.freelist, nil)</span>
}

// Shim function that's expected to wrap any invocations of WebAssembly from Go
// itself.
func enterWasm(freelist *freeList, wasm func(**C.wasm_trap_t)) *Trap <span class="cov8" title="1">{
        // First thing we need to do is update `gCallerState` with the actual
        // pointer to `freelist` since when calling wasm we may call a Go
        // function which needs the freelist.
        //
        // Note that if there's already an entry in the map we just increase
        // the reference count.
        gLock.Lock()
        caller_id := C.size_t(uintptr(unsafe.Pointer(freelist)))
        if _, ok := gCallerState[caller_id]; !ok </span><span class="cov8" title="1">{
                gCallerState[caller_id] = &amp;callerState{freelist: freelist}
        }</span>
        <span class="cov8" title="1">gCallerState[caller_id].cnt++
        gLock.Unlock()

        // After `gCallerState` is configured we can actually enter the wasm
        // code. We handle traps/panics here so we pass in the trap pointer.
        //
        // Note that it's assumed that this never panics.
        var trap *C.wasm_trap_t
        wasm(&amp;trap)

        // After wasm has finished we need to remove `freelist` from the global
        // `gCallerState` map to ensure it can eventually get GC'd. Here we
        // also propagate any Go-originating panics if they're found.
        gLock.Lock()
        state := gCallerState[caller_id]
        lastPanic := state.lastPanic
        state.lastPanic = nil
        state.cnt--
        if state.cnt == 0 </span><span class="cov8" title="1">{
                delete(gCallerState, caller_id)
        }</span>
        <span class="cov8" title="1">gLock.Unlock()

        // Take ownership of the return trapped pointer to ensure we don't leak
        // it, even if Go panicked.
        var wrappedTrap *Trap
        if trap != nil </span><span class="cov8" title="1">{
                wrappedTrap = mkTrap(trap)
        }</span>

        // Check to see if we called a Go host function which panicked, in
        // which case we propagate that here.
        <span class="cov8" title="1">if lastPanic != nil </span><span class="cov8" title="1">{
                panic(lastPanic)</span>
        }

        // And otherwise if Go didn't panic we return whether the function
        // trapped or not.
        <span class="cov8" title="1">return wrappedTrap</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import (
        "runtime"
        "unsafe"
)

// FuncType is one of function types which classify the signature of functions, mapping a vector of parameters to a vector of results.
// They are also used to classify the inputs and outputs of instructions.
type FuncType struct {
        _ptr   *C.wasm_functype_t
        _owner interface{}
}

// NewFuncType creates a new `FuncType` with the `kind` provided
func NewFuncType(params, results []*ValType) *FuncType <span class="cov8" title="1">{
        paramVec := mkValTypeList(params)
        resultVec := mkValTypeList(results)

        ptr := C.wasm_functype_new(&amp;paramVec, &amp;resultVec)

        return mkFuncType(ptr, nil)
}</span>

func mkValTypeList(tys []*ValType) C.wasm_valtype_vec_t <span class="cov8" title="1">{
        vec := C.wasm_valtype_vec_t{}
        C.wasm_valtype_vec_new_uninitialized(&amp;vec, C.size_t(len(tys)))
        base := unsafe.Pointer(vec.data)
        for i, ty := range tys </span><span class="cov8" title="1">{
                ptr := C.wasm_valtype_new(C.wasm_valtype_kind(ty.ptr()))
                *(**C.wasm_valtype_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i))) = ptr
        }</span>
        <span class="cov8" title="1">runtime.KeepAlive(tys)
        return vec</span>
}

func mkFuncType(ptr *C.wasm_functype_t, owner interface{}) *FuncType <span class="cov8" title="1">{
        functype := &amp;FuncType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(functype, func(functype *FuncType) </span><span class="cov8" title="1">{
                        C.wasm_functype_delete(functype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return functype</span>
}

func (ty *FuncType) ptr() *C.wasm_functype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *FuncType) owner() interface{} <span class="cov8" title="1">{
        if ty._owner != nil </span><span class="cov0" title="0">{
                return ty._owner
        }</span>
        <span class="cov8" title="1">return ty</span>
}

// Params returns the parameter types of this function type
func (ty *FuncType) Params() []*ValType <span class="cov8" title="1">{
        ptr := C.wasm_functype_params(ty.ptr())
        return ty.convertTypeList(ptr)
}</span>

// Results returns the result types of this function type
func (ty *FuncType) Results() []*ValType <span class="cov8" title="1">{
        ptr := C.wasm_functype_results(ty.ptr())
        return ty.convertTypeList(ptr)
}</span>

func (ty *FuncType) convertTypeList(list *C.wasm_valtype_vec_t) []*ValType <span class="cov8" title="1">{
        ret := make([]*ValType, list.size)

        base := unsafe.Pointer(list.data)
        var ptr *C.wasm_valtype_t
        for i := 0; i &lt; int(list.size); i++ </span><span class="cov8" title="1">{
                ptr := *(**C.wasm_valtype_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i)))
                ty := mkValType(ptr, ty.owner())
                ret[i] = ty
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// AsExternType converts this type to an instance of `ExternType`
func (ty *FuncType) AsExternType() *ExternType <span class="cov8" title="1">{
        ptr := C.wasm_functype_as_externtype_const(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
import "C"
import "runtime"

// Global is a global instance, which is the runtime representation of a global variable.
// It holds an individual value and a flag indicating whether it is mutable.
// Read more in [spec](https://webassembly.github.io/spec/core/exec/runtime.html#global-instances)
type Global struct {
        _ptr     *C.wasm_global_t
        _owner   interface{}
        freelist *freeList
}

// NewGlobal creates a new `Global` in the given `Store` with the specified `ty` and
// initial value `val`.
func NewGlobal(
        store *Store,
        ty *GlobalType,
        val Val,
) (*Global, error) <span class="cov8" title="1">{
        var ptr *C.wasm_global_t
        err := C.wasmtime_global_new(
                store.ptr(),
                ty.ptr(),
                val.ptr(),
                &amp;ptr,
        )
        runtime.KeepAlive(store)
        runtime.KeepAlive(ty)
        runtime.KeepAlive(val)
        if err != nil </span><span class="cov8" title="1">{
                return nil, mkError(err)
        }</span>

        <span class="cov8" title="1">return mkGlobal(ptr, store.freelist, nil), nil</span>
}

func mkGlobal(ptr *C.wasm_global_t, freelist *freeList, owner interface{}) *Global <span class="cov8" title="1">{
        f := &amp;Global{_ptr: ptr, _owner: owner, freelist: freelist}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(f, func(f *Global) </span><span class="cov8" title="1">{
                        f.freelist.lock.Lock()
                        defer f.freelist.lock.Unlock()
                        f.freelist.globals = append(f.freelist.globals, f._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return f</span>
}

func (g *Global) ptr() *C.wasm_global_t <span class="cov8" title="1">{
        ret := g._ptr
        maybeGC()
        return ret
}</span>

func (g *Global) owner() interface{} <span class="cov8" title="1">{
        if g._owner != nil </span><span class="cov0" title="0">{
                return g._owner
        }</span>
        <span class="cov8" title="1">return g</span>
}

// Type returns the type of this global
func (g *Global) Type() *GlobalType <span class="cov8" title="1">{
        ptr := C.wasm_global_type(g.ptr())
        runtime.KeepAlive(g)
        return mkGlobalType(ptr, nil)
}</span>

// Get gets the value of this global
func (g *Global) Get() Val <span class="cov8" title="1">{
        ret := C.wasm_val_t{}
        C.wasm_global_get(g.ptr(), &amp;ret)
        runtime.KeepAlive(g)
        return takeVal(&amp;ret, g.freelist)
}</span>

// Set sets the value of this global
func (g *Global) Set(val Val) error <span class="cov8" title="1">{
        err := C.wasmtime_global_set(g.ptr(), val.ptr())
        runtime.KeepAlive(g)
        runtime.KeepAlive(val)
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkError(err)</span>
}

func (g *Global) AsExtern() *Extern <span class="cov8" title="1">{
        ptr := C.wasm_global_as_extern(g.ptr())
        return mkExtern(ptr, g.freelist, g.owner())
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// GlobalType is a ValType, which classify global variables and hold a value and can either be mutable or immutable.
type GlobalType struct {
        _ptr   *C.wasm_globaltype_t
        _owner interface{}
}

// NewGlobalType creates a new `GlobalType` with the `kind` provided and whether it's
// `mutable` or not
func NewGlobalType(content *ValType, mutable bool) *GlobalType <span class="cov8" title="1">{
        mutability := C.WASM_CONST
        if mutable </span><span class="cov8" title="1">{
                mutability = C.WASM_VAR
        }</span>
        <span class="cov8" title="1">contentPtr := C.wasm_valtype_new(C.wasm_valtype_kind(content.ptr()))
        runtime.KeepAlive(content)
        ptr := C.wasm_globaltype_new(contentPtr, C.wasm_mutability_t(mutability))

        return mkGlobalType(ptr, nil)</span>
}

func mkGlobalType(ptr *C.wasm_globaltype_t, owner interface{}) *GlobalType <span class="cov8" title="1">{
        globaltype := &amp;GlobalType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(globaltype, func(globaltype *GlobalType) </span><span class="cov8" title="1">{
                        C.wasm_globaltype_delete(globaltype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return globaltype</span>
}

func (ty *GlobalType) ptr() *C.wasm_globaltype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *GlobalType) owner() interface{} <span class="cov8" title="1">{
        if ty._owner != nil </span><span class="cov8" title="1">{
                return ty._owner
        }</span>
        <span class="cov8" title="1">return ty</span>
}

// Content returns the type of value stored in this global
func (ty *GlobalType) Content() *ValType <span class="cov8" title="1">{
        ptr := C.wasm_globaltype_content(ty.ptr())
        return mkValType(ptr, ty.owner())
}</span>

// Mutable returns whether this global type is mutable or not
func (ty *GlobalType) Mutable() bool <span class="cov8" title="1">{
        ret := C.wasm_globaltype_mutability(ty.ptr()) == C.WASM_VAR
        runtime.KeepAlive(ty)
        return ret
}</span>

// AsExternType converts this type to an instance of `ExternType`
func (ty *GlobalType) AsExternType() *ExternType <span class="cov8" title="1">{
        ptr := C.wasm_globaltype_as_externtype_const(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// ImportType is one of the imports component
// A module defines a set of imports that are required for instantiation.
type ImportType struct {
        _ptr   *C.wasm_importtype_t
        _owner interface{}
}

// NewImportType creates a new `ImportType` with the given `module` and `name` and the type
// provided.
func NewImportType(module, name string, ty AsExternType) *ImportType <span class="cov8" title="1">{
        moduleVec := stringToByteVec(module)
        nameVec := stringToByteVec(name)

        // Creating an import type requires taking ownership, so create a copy
        // so we don't have to invalidate pointers here. Shouldn't be too
        // costly in theory anyway.
        extern := ty.AsExternType()
        ptr := C.wasm_externtype_copy(extern.ptr())
        runtime.KeepAlive(extern)

        // And once we've got all that create the import type!
        importPtr := C.wasm_importtype_new(&amp;moduleVec, &amp;nameVec, ptr)

        return mkImportType(importPtr, nil)
}</span>

func mkImportType(ptr *C.wasm_importtype_t, owner interface{}) *ImportType <span class="cov8" title="1">{
        importtype := &amp;ImportType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(importtype, func(importtype *ImportType) </span><span class="cov8" title="1">{
                        C.wasm_importtype_delete(importtype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return importtype</span>
}

func (ty *ImportType) ptr() *C.wasm_importtype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *ImportType) owner() interface{} <span class="cov8" title="1">{
        if ty._owner != nil </span><span class="cov8" title="1">{
                return ty._owner
        }</span>
        <span class="cov8" title="1">return ty</span>
}

// Module returns the name in the module this import type is importing
func (ty *ImportType) Module() string <span class="cov8" title="1">{
        ptr := C.wasm_importtype_module(ty.ptr())
        ret := C.GoStringN(ptr.data, C.int(ptr.size))
        runtime.KeepAlive(ty)
        return ret
}</span>

// Name returns the name in the module this import type is importing.
//
// Note that the returned string may be `nil` with the module linking proposal
// where this field is optional in the import type.
func (ty *ImportType) Name() *string <span class="cov8" title="1">{
        ptr := C.wasm_importtype_name(ty.ptr())
        if ptr == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ret := C.GoStringN(ptr.data, C.int(ptr.size))
        runtime.KeepAlive(ty)
        return &amp;ret</span>
}

// Type returns the type of item this import type expects
func (ty *ImportType) Type() *ExternType <span class="cov8" title="1">{
        ptr := C.wasm_importtype_type(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
import "C"
import (
        "runtime"
        "unsafe"
)

// Instance is an instantiated module instance.
// Once a module has been instantiated as an Instance, any exported function can be invoked externally via its function address funcaddr in the store S and an appropriate list val∗ of argument values.
type Instance struct {
        _ptr             *C.wasm_instance_t
        exports          map[string]*Extern
        exportsPopulated bool
        freelist         *freeList
        _owner           interface{}
}

// NewInstance instantiates a WebAssembly `module` with the `imports` provided.
//
// This function will attempt to create a new wasm instance given the provided
// imports. This can fail if the wrong number of imports are specified, the
// imports aren't of the right type, or for other resource-related issues.
//
// This will also run the `start` function of the instance, returning an error
// if it traps.
func NewInstance(store *Store, module *Module, imports []*Extern) (*Instance, error) <span class="cov8" title="1">{
        importsRaw := C.wasm_extern_vec_t{}
        C.wasm_extern_vec_new_uninitialized(&amp;importsRaw, C.size_t(len(imports)))
        base := unsafe.Pointer(importsRaw.data)
        for i, imp := range imports </span><span class="cov8" title="1">{
                ptr := C.wasm_extern_copy(imp.ptr())
                *(**C.wasm_extern_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i))) = ptr
        }</span>
        <span class="cov8" title="1">var ptr *C.wasm_instance_t
        var err *C.wasmtime_error_t
        trap := enterWasm(store.freelist, func(trap **C.wasm_trap_t) </span><span class="cov8" title="1">{
                err = C.wasmtime_instance_new(
                        store.ptr(),
                        module.ptr(),
                        &amp;importsRaw,
                        &amp;ptr,
                        trap,
                )
        }</span>)
        <span class="cov8" title="1">runtime.KeepAlive(store)
        runtime.KeepAlive(module)
        C.wasm_extern_vec_delete(&amp;importsRaw)
        if trap != nil </span><span class="cov8" title="1">{
                return nil, trap
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, mkError(err)
        }</span>
        <span class="cov8" title="1">return mkInstance(ptr, store.freelist, nil), nil</span>
}

func mkInstance(ptr *C.wasm_instance_t, freelist *freeList, owner interface{}) *Instance <span class="cov8" title="1">{
        instance := &amp;Instance{
                _ptr:             ptr,
                exports:          make(map[string]*Extern),
                exportsPopulated: false,
                freelist:         freelist,
                _owner:           owner,
        }
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(instance, func(instance *Instance) </span><span class="cov8" title="1">{
                        freelist := instance.freelist
                        freelist.lock.Lock()
                        defer freelist.lock.Unlock()
                        freelist.instances = append(freelist.instances, instance._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return instance</span>
}

func (i *Instance) ptr() *C.wasm_instance_t <span class="cov8" title="1">{
        ret := i._ptr
        maybeGC()
        return ret
}</span>

func (i *Instance) owner() interface{} <span class="cov8" title="1">{
        if i._owner != nil </span><span class="cov0" title="0">{
                return i._owner
        }</span>
        <span class="cov8" title="1">return i</span>
}

// Type returns an `InstanceType` that corresponds for this instance.
func (i *Instance) Type() *InstanceType <span class="cov8" title="1">{
        ptr := C.wasm_instance_type(i.ptr())
        runtime.KeepAlive(i)
        return mkInstanceType(ptr, nil)
}</span>

type externList struct {
        vec C.wasm_extern_vec_t
}

// Exports returns a list of exports from this instance.
//
// Each export is returned as a `*Extern` and lines up with the exports list of
// the associated `Module`.
func (i *Instance) Exports() []*Extern <span class="cov8" title="1">{
        externs := &amp;externList{}
        C.wasm_instance_exports(i.ptr(), &amp;externs.vec)
        runtime.KeepAlive(i)
        freelist := i.freelist
        runtime.SetFinalizer(externs, func(externs *externList) </span><span class="cov8" title="1">{
                freelist.lock.Lock()
                defer freelist.lock.Unlock()
                freelist.externVecs = append(freelist.externVecs, &amp;externs.vec)
        }</span>)

        <span class="cov8" title="1">ret := make([]*Extern, int(externs.vec.size))
        base := unsafe.Pointer(externs.vec.data)
        var ptr *C.wasm_extern_t
        for i := 0; i &lt; int(externs.vec.size); i++ </span><span class="cov8" title="1">{
                ptr := *(**C.wasm_extern_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i)))
                ty := mkExtern(ptr, freelist, externs)
                ret[i] = ty
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// GetExport attempts to find an export on this instance by `name`
//
// May return `nil` if this instance has no export named `name`
func (i *Instance) GetExport(name string) *Extern <span class="cov8" title="1">{
        if !i.exportsPopulated </span><span class="cov8" title="1">{
                i.populateExports()
        }</span>
        <span class="cov8" title="1">return i.exports[name]</span>
}

func (i *Instance) populateExports() <span class="cov8" title="1">{
        exports := i.Exports()
        for j, ty := range i.Type().Exports() </span><span class="cov8" title="1">{
                i.exports[ty.Name()] = exports[j]
        }</span>
}

func (i *Instance) AsExtern() *Extern <span class="cov8" title="1">{
        ptr := C.wasm_instance_as_extern(i.ptr())
        return mkExtern(ptr, i.freelist, i.owner())
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
import "C"
import "runtime"

// InstanceType describes the exports of an instance.
type InstanceType struct {
        _ptr   *C.wasm_instancetype_t
        _owner interface{}
}

func mkInstanceType(ptr *C.wasm_instancetype_t, owner interface{}) *InstanceType <span class="cov8" title="1">{
        instancetype := &amp;InstanceType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(instancetype, func(instancetype *InstanceType) </span><span class="cov8" title="1">{
                        C.wasm_instancetype_delete(instancetype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return instancetype</span>
}

func (ty *InstanceType) ptr() *C.wasm_instancetype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *InstanceType) owner() interface{} <span class="cov0" title="0">{
        if ty._owner != nil </span><span class="cov0" title="0">{
                return ty._owner
        }</span>
        <span class="cov0" title="0">return ty</span>
}

// AsExternType converts this type to an instance of `ExternType`
func (ty *InstanceType) AsExternType() *ExternType <span class="cov0" title="0">{
        ptr := C.wasm_instancetype_as_externtype_const(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>

// Exports returns a list of `ExportType` items which are the items that will
// be exported by this instance after instantiation.
func (ty *InstanceType) Exports() []*ExportType <span class="cov8" title="1">{
        exports := &amp;exportTypeList{}
        C.wasm_instancetype_exports(ty.ptr(), &amp;exports.vec)
        runtime.KeepAlive(ty)
        return exports.mkGoList()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// LimitsMaxNone is the value for the Max field in Limits
const LimitsMaxNone = 0xffffffff

// Limits is the resource limits specified for a TableType and MemoryType
type Limits struct {
        // The minimum size of this resource, in units specified by the resource
        // itself.
        Min uint32
        // The maximum size of this resource, in units specified by the resource
        // itself.
        //
        // A value of LimitsMaxNone will mean that there is no maximum.
        Max uint32
}

// NewLimits creates a new resource limits specified for a TableType and MemoryType,
// in which min and max are the minimum and maximum size of this resource.
func NewLimits(min, max uint32) *Limits <span class="cov0" title="0">{
        return &amp;Limits{
                Min: min,
                Max: max,
        }
}</span>

func (limits Limits) ffi() C.wasm_limits_t <span class="cov8" title="1">{
        return C.wasm_limits_t{
                min: C.uint32_t(limits.Min),
                max: C.uint32_t(limits.Max),
        }
}</span>

func mkLimits(ptr *C.wasm_limits_t, owner interface{}) Limits <span class="cov8" title="1">{
        ret := Limits{
                Min: uint32(ptr.min),
                Max: uint32(ptr.max),
        }
        runtime.KeepAlive(owner)
        return ret
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
// #include "shims.h"
import "C"
import "runtime"

// Linker implements a wasmtime Linking module, which can link instantiated modules together.
// More details you can see [examples for C](https://bytecodealliance.github.io/wasmtime/examples-c-linking.html) or
// [examples for Rust](https://bytecodealliance.github.io/wasmtime/examples-rust-linking.html)
type Linker struct {
        _ptr  *C.wasmtime_linker_t
        Store *Store
}

func NewLinker(store *Store) *Linker <span class="cov8" title="1">{
        ptr := C.wasmtime_linker_new(store.ptr())
        runtime.KeepAlive(store)
        return mkLinker(ptr, store)
}</span>

func mkLinker(ptr *C.wasmtime_linker_t, store *Store) *Linker <span class="cov8" title="1">{
        linker := &amp;Linker{_ptr: ptr, Store: store}
        runtime.SetFinalizer(linker, func(linker *Linker) </span><span class="cov8" title="1">{
                freelist := linker.Store.freelist
                freelist.lock.Lock()
                defer freelist.lock.Unlock()
                freelist.linkers = append(freelist.linkers, linker._ptr)
        }</span>)
        <span class="cov8" title="1">return linker</span>
}

func (l *Linker) ptr() *C.wasmtime_linker_t <span class="cov8" title="1">{
        ret := l._ptr
        maybeGC()
        return ret
}</span>

// AllowShadowing configures whether names can be redefined after they've already been defined
// in this linker.
func (l *Linker) AllowShadowing(allow bool) <span class="cov8" title="1">{
        C.wasmtime_linker_allow_shadowing(l.ptr(), C.bool(allow))
        runtime.KeepAlive(l)
}</span>

// Define defines a new item in this linker with the given module/name pair. Returns
// an error if shadowing is disallowed and the module/name is already defined.
func (l *Linker) Define(module, name string, item AsExtern) error <span class="cov8" title="1">{
        extern := item.AsExtern()
        err := C.go_linker_define(
                l.ptr(),
                C._GoStringPtr(module),
                C._GoStringLen(module),
                C._GoStringPtr(name),
                C._GoStringLen(name),
                extern.ptr(),
        )
        runtime.KeepAlive(l)
        runtime.KeepAlive(module)
        runtime.KeepAlive(name)
        runtime.KeepAlive(extern)
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkError(err)</span>
}

// DefineFunc acts as a convenience wrapper to calling Define and WrapFunc.
//
// Returns an error if shadowing is disabled and the name is already defined.
func (l *Linker) DefineFunc(module, name string, f interface{}) error <span class="cov8" title="1">{
        return l.Define(module, name, WrapFunc(l.Store, f))
}</span>

// DefineInstance defines all exports of an instance provided under the module name provided.
//
// Returns an error if shadowing is disabled and names are already defined.
func (l *Linker) DefineInstance(module string, instance *Instance) error <span class="cov8" title="1">{
        err := C.go_linker_define_instance(
                l.ptr(),
                C._GoStringPtr(module),
                C._GoStringLen(module),
                instance.ptr(),
        )
        runtime.KeepAlive(l)
        runtime.KeepAlive(module)
        runtime.KeepAlive(instance)
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkError(err)</span>
}

// DefineWasi links a WASI module into this linker, ensuring that all exported functions
// are available for linking.
//
// Returns an error if shadowing is disabled and names are already defined.
func (l *Linker) DefineWasi(instance *WasiInstance) error <span class="cov8" title="1">{
        err := C.wasmtime_linker_define_wasi(l.ptr(), instance.ptr())
        runtime.KeepAlive(l)
        runtime.KeepAlive(instance)
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return mkError(err)</span>
}

// Instantiate instantates a module with all imports defined in this linker.
//
// Returns an error if the instance's imports couldn't be satisfied, had the
// wrong types, or if a trap happened executing the start function.
func (l *Linker) Instantiate(module *Module) (*Instance, error) <span class="cov8" title="1">{
        var ret *C.wasm_instance_t
        var err *C.wasmtime_error_t
        trap := enterWasm(l.Store.freelist, func(trap **C.wasm_trap_t) </span><span class="cov8" title="1">{
                err = C.wasmtime_linker_instantiate(l.ptr(), module.ptr(), &amp;ret, trap)
        }</span>)
        <span class="cov8" title="1">runtime.KeepAlive(l)
        runtime.KeepAlive(module)
        if trap != nil </span><span class="cov8" title="1">{
                return nil, trap
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, mkError(err)
        }</span>
        <span class="cov8" title="1">return mkInstance(ret, l.Store.freelist, nil), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// +build !debug

package wasmtime

// See `ffi.go` documentation about `ptr()` for what's going on here.

func maybeGC() {<span class="cov8" title="1">
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import (
        "runtime"
        "unsafe"
)

// Memory instance is the runtime representation of a linear memory.
// It holds a vector of bytes and an optional maximum size, if one was specified at the definition site of the memory.
// Read more in [spec](https://webassembly.github.io/spec/core/exec/runtime.html#memory-instances)
// In wasmtime-go, you can get the vector of bytes by the unsafe pointer of memory from `Memory.Data()`, or go style byte slice from `Memory.UnsafeData()`
type Memory struct {
        _ptr     *C.wasm_memory_t
        freelist *freeList
        _owner   interface{}
}

// NewMemory creates a new `Memory` in the given `Store` with the specified `ty`.
func NewMemory(store *Store, ty *MemoryType) *Memory <span class="cov8" title="1">{
        ptr := C.wasm_memory_new(store.ptr(), ty.ptr())
        runtime.KeepAlive(store)
        runtime.KeepAlive(ty)
        return mkMemory(ptr, store.freelist, nil)
}</span>

func mkMemory(ptr *C.wasm_memory_t, freelist *freeList, owner interface{}) *Memory <span class="cov8" title="1">{
        f := &amp;Memory{_ptr: ptr, _owner: owner, freelist: freelist}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(f, func(f *Memory) </span><span class="cov8" title="1">{
                        f.freelist.lock.Lock()
                        defer f.freelist.lock.Unlock()
                        f.freelist.memories = append(f.freelist.memories, f._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return f</span>
}

func (mem *Memory) ptr() *C.wasm_memory_t <span class="cov8" title="1">{
        ret := mem._ptr
        maybeGC()
        return ret
}</span>

func (mem *Memory) owner() interface{} <span class="cov8" title="1">{
        if mem._owner != nil </span><span class="cov0" title="0">{
                return mem._owner
        }</span>
        <span class="cov8" title="1">return mem</span>
}

// Type returns the type of this memory
func (mem *Memory) Type() *MemoryType <span class="cov8" title="1">{
        ptr := C.wasm_memory_type(mem.ptr())
        runtime.KeepAlive(mem)
        return mkMemoryType(ptr, nil)
}</span>

// Data returns the raw pointer in memory of where this memory starts
func (mem *Memory) Data() unsafe.Pointer <span class="cov8" title="1">{
        ret := unsafe.Pointer(C.wasm_memory_data(mem.ptr()))
        runtime.KeepAlive(mem)
        return ret
}</span>

// UnsafeData returns the raw memory backed by this `Memory` as a byte slice (`[]byte`).
//
// This is not a safe method to call, hence the "unsafe" in the name. The byte
// slice returned from this function is not managed by the Go garbage collector.
// You need to ensure that `m`, the original `Memory`, lives longer than the
// `[]byte` returned.
//
// Note that you may need to use `runtime.KeepAlive` to keep the original memory
// `m` alive for long enough while you're using the `[]byte` slice. If the
// `[]byte` slice is used after `m` is GC'd then that is undefined behavior.
func (mem *Memory) UnsafeData() []byte <span class="cov8" title="1">{
        // see https://github.com/golang/go/wiki/cgo#turning-c-arrays-into-go-slices
        const MaxLen = 1 &lt;&lt; 32
        length := mem.DataSize()
        if length &gt;= MaxLen </span><span class="cov0" title="0">{
                panic("memory is too big")</span>
        }
        <span class="cov8" title="1">return (*[MaxLen]byte)(mem.Data())[:length:length]</span>
}

// DataSize returns the size, in bytes, that `Data()` is valid for
func (mem *Memory) DataSize() uintptr <span class="cov8" title="1">{
        ret := uintptr(C.wasm_memory_data_size(mem.ptr()))
        runtime.KeepAlive(mem)
        return ret
}</span>

// Size returns the size, in wasm pages, of this memory
func (mem *Memory) Size() uint32 <span class="cov8" title="1">{
        ret := uint32(C.wasm_memory_size(mem.ptr()))
        runtime.KeepAlive(mem)
        return ret
}</span>

// Grow grows this memory by `delta` pages
func (mem *Memory) Grow(delta uint) bool <span class="cov8" title="1">{
        ret := C.wasm_memory_grow(mem.ptr(), C.wasm_memory_pages_t(delta))
        runtime.KeepAlive(mem)
        return bool(ret)
}</span>

func (mem *Memory) AsExtern() *Extern <span class="cov8" title="1">{
        ptr := C.wasm_memory_as_extern(mem.ptr())
        return mkExtern(ptr, mem.freelist, mem.owner())
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// MemoryType is one of Memory types which classify linear memories and their size range.
// The limits constrain the minimum and optionally the maximum size of a memory. The limits are given in units of page size.
type MemoryType struct {
        _ptr   *C.wasm_memorytype_t
        _owner interface{}
}

// NewMemoryType creates a new `MemoryType` with the `limits` on size provided
func NewMemoryType(limits Limits) *MemoryType <span class="cov8" title="1">{
        limitsFFI := limits.ffi()
        ptr := C.wasm_memorytype_new(&amp;limitsFFI)
        return mkMemoryType(ptr, nil)
}</span>

func mkMemoryType(ptr *C.wasm_memorytype_t, owner interface{}) *MemoryType <span class="cov8" title="1">{
        memorytype := &amp;MemoryType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(memorytype, func(memorytype *MemoryType) </span><span class="cov8" title="1">{
                        C.wasm_memorytype_delete(memorytype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return memorytype</span>
}

func (ty *MemoryType) ptr() *C.wasm_memorytype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *MemoryType) owner() interface{} <span class="cov8" title="1">{
        if ty._owner != nil </span><span class="cov8" title="1">{
                return ty._owner
        }</span>
        <span class="cov8" title="1">return ty</span>
}

// Limits returns the limits on the size of this memory type
func (ty *MemoryType) Limits() Limits <span class="cov8" title="1">{
        ptr := C.wasm_memorytype_limits(ty.ptr())
        return mkLimits(ptr, ty.owner())
}</span>

// AsExternType converts this type to an instance of `ExternType`
func (ty *MemoryType) AsExternType() *ExternType <span class="cov8" title="1">{
        ptr := C.wasm_memorytype_as_externtype_const(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
//
// wasmtime_error_t *go_module_new(wasm_engine_t *engine, uint8_t *bytes, size_t len, wasm_module_t **ret) {
//    wasm_byte_vec_t vec;
//    vec.data = (wasm_byte_t*) bytes;
//    vec.size = len;
//    return wasmtime_module_new(engine, &amp;vec, ret);
// }
//
// wasmtime_error_t *go_module_validate(wasm_store_t *store, uint8_t *bytes, size_t len) {
//    wasm_byte_vec_t vec;
//    vec.data = (wasm_byte_t*) bytes;
//    vec.size = len;
//    return wasmtime_module_validate(store, &amp;vec);
// }
//
// wasmtime_error_t *go_module_deserialize(wasm_engine_t *engine, uint8_t *bytes, size_t len, wasm_module_t **ret) {
//    wasm_byte_vec_t vec;
//    vec.data = (wasm_byte_t*) bytes;
//    vec.size = len;
//    return wasmtime_module_deserialize(engine, &amp;vec, ret);
// }
import "C"
import (
        "io/ioutil"
        "runtime"
        "unsafe"
)

// Module is a module which collects definitions for types, functions, tables, memories, and globals.
// In addition, it can declare imports and exports and provide initialization logic in the form of data and element segments or a start function.
// Modules organized WebAssembly programs as the unit of deployment, loading, and compilation.
type Module struct {
        _ptr   *C.wasm_module_t
        _owner interface{}
}

// NewModule compiles a new `Module` from the `wasm` provided with the given configuration
// in `engine`.
func NewModule(engine *Engine, wasm []byte) (*Module, error) <span class="cov8" title="1">{
        // We can't create the `wasm_byte_vec_t` here and pass it in because
        // that runs into the error of "passed a pointer to a pointer" because
        // the vec itself is passed by pointer and it contains a pointer to
        // `wasm`. To work around this we insert some C shims above and call
        // them.
        var wasmPtr *C.uint8_t
        if len(wasm) &gt; 0 </span><span class="cov8" title="1">{
                wasmPtr = (*C.uint8_t)(unsafe.Pointer(&amp;wasm[0]))
        }</span>
        <span class="cov8" title="1">var ptr *C.wasm_module_t
        err := C.go_module_new(engine.ptr(), wasmPtr, C.size_t(len(wasm)), &amp;ptr)
        runtime.KeepAlive(engine)
        runtime.KeepAlive(wasm)

        if err != nil </span><span class="cov8" title="1">{
                return nil, mkError(err)
        }</span>

        <span class="cov8" title="1">return mkModule(ptr, nil), nil</span>
}

// NewModuleFromFile reads the contents of the `file` provided and interprets them as either the
// text format or the binary format for WebAssembly.
//
// Afterwards delegates to the `NewModule` constructor with the contents read.
func NewModuleFromFile(engine *Engine, file string) (*Module, error) <span class="cov0" title="0">{
        wasm, err := ioutil.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // If this wasm isn't actually wasm, treat it as the text format and
        // parse it as such.
        <span class="cov0" title="0">if len(wasm) &gt; 0 &amp;&amp; wasm[0] != 0 </span><span class="cov0" title="0">{
                wasm, err = Wat2Wasm(string(wasm))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return NewModule(engine, wasm)</span>

}

// ModuleValidate validates whether `wasm` would be a valid wasm module according to the
// configuration in `store`
func ModuleValidate(store *Store, wasm []byte) error <span class="cov8" title="1">{
        var wasmPtr *C.uint8_t
        if len(wasm) &gt; 0 </span><span class="cov8" title="1">{
                wasmPtr = (*C.uint8_t)(unsafe.Pointer(&amp;wasm[0]))
        }</span>
        <span class="cov8" title="1">err := C.go_module_validate(store.ptr(), wasmPtr, C.size_t(len(wasm)))
        runtime.KeepAlive(store)
        runtime.KeepAlive(wasm)
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return mkError(err)</span>
}

func mkModule(ptr *C.wasm_module_t, owner interface{}) *Module <span class="cov8" title="1">{
        module := &amp;Module{_ptr: ptr}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(module, func(module *Module) </span><span class="cov8" title="1">{
                        C.wasm_module_delete(module._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return module</span>
}

func (m *Module) ptr() *C.wasm_module_t <span class="cov8" title="1">{
        ret := m._ptr
        maybeGC()
        return ret
}</span>

func (m *Module) owner() interface{} <span class="cov8" title="1">{
        if m._owner != nil </span><span class="cov0" title="0">{
                return m._owner
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Type returns a `ModuleType` that corresponds for this module.
func (m *Module) Type() *ModuleType <span class="cov8" title="1">{
        ptr := C.wasm_module_type(m.ptr())
        runtime.KeepAlive(m)
        return mkModuleType(ptr, nil)
}</span>

type importTypeList struct {
        vec C.wasm_importtype_vec_t
}

func (list *importTypeList) mkGoList() []*ImportType <span class="cov8" title="1">{
        runtime.SetFinalizer(list, func(imports *importTypeList) </span><span class="cov8" title="1">{
                C.wasm_importtype_vec_delete(&amp;imports.vec)
        }</span>)

        <span class="cov8" title="1">ret := make([]*ImportType, int(list.vec.size))
        base := unsafe.Pointer(list.vec.data)
        var ptr *C.wasm_importtype_t
        for i := 0; i &lt; int(list.vec.size); i++ </span><span class="cov8" title="1">{
                ptr := *(**C.wasm_importtype_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i)))
                ty := mkImportType(ptr, list)
                ret[i] = ty
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// Imports returns a list of `ImportType` items which are the items imported by this
// module and are required for instantiation.
func (m *Module) Imports() []*ImportType <span class="cov8" title="1">{
        imports := &amp;importTypeList{}
        C.wasm_module_imports(m.ptr(), &amp;imports.vec)
        runtime.KeepAlive(m)
        runtime.SetFinalizer(imports, func(imports *importTypeList) </span><span class="cov8" title="1">{
                C.wasm_importtype_vec_delete(&amp;imports.vec)
        }</span>)

        <span class="cov8" title="1">ret := make([]*ImportType, int(imports.vec.size))
        base := unsafe.Pointer(imports.vec.data)
        var ptr *C.wasm_importtype_t
        for i := 0; i &lt; int(imports.vec.size); i++ </span><span class="cov8" title="1">{
                ptr := *(**C.wasm_importtype_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i)))
                ty := mkImportType(ptr, imports)
                ret[i] = ty
        }</span>
        <span class="cov8" title="1">return ret</span>
}

type exportTypeList struct {
        vec C.wasm_exporttype_vec_t
}

func (list *exportTypeList) mkGoList() []*ExportType <span class="cov8" title="1">{
        runtime.SetFinalizer(list, func(exports *exportTypeList) </span><span class="cov8" title="1">{
                C.wasm_exporttype_vec_delete(&amp;exports.vec)
        }</span>)

        <span class="cov8" title="1">ret := make([]*ExportType, int(list.vec.size))
        base := unsafe.Pointer(list.vec.data)
        var ptr *C.wasm_exporttype_t
        for i := 0; i &lt; int(list.vec.size); i++ </span><span class="cov8" title="1">{
                ptr := *(**C.wasm_exporttype_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i)))
                ty := mkExportType(ptr, list)
                ret[i] = ty
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// Exports returns a list of `ExportType` items which are the items that will
// be exported by this module after instantiation.
func (m *Module) Exports() []*ExportType <span class="cov8" title="1">{
        exports := &amp;exportTypeList{}
        C.wasm_module_exports(m.ptr(), &amp;exports.vec)
        runtime.KeepAlive(m)
        return exports.mkGoList()
}</span>

// NewModuleDeserialize decodes and deserializes in-memory bytes previously
// produced by `module.Serialize()`.
//
// This function does not take a WebAssembly binary as input. It takes
// as input the results of a previous call to `Serialize()`, and only takes
// that as input.
//
// If deserialization is successful then a compiled module is returned,
// otherwise nil and an error are returned.
//
// Note that to deserialize successfully the bytes provided must have beeen
// produced with an `Engine` that has the same commpilation options as the
// provided engine, and from the same version of this library.
func NewModuleDeserialize(engine *Engine, encoded []byte) (*Module, error) <span class="cov8" title="1">{
        var encodedPtr *C.uint8_t
        var ptr *C.wasm_module_t
        if len(encoded) &gt; 0 </span><span class="cov8" title="1">{
                encodedPtr = (*C.uint8_t)(unsafe.Pointer(&amp;encoded[0]))
        }</span>
        <span class="cov8" title="1">err := C.go_module_deserialize(
                engine.ptr(),
                encodedPtr,
                C.size_t(len(encoded)),
                &amp;ptr,
        )
        runtime.KeepAlive(engine)
        runtime.KeepAlive(encoded)

        if err != nil </span><span class="cov0" title="0">{
                return nil, mkError(err)
        }</span>

        <span class="cov8" title="1">return mkModule(ptr, nil), nil</span>
}

// Serialize will convert this in-memory compiled module into a list of bytes.
//
// The purpose of this method is to extract an artifact which can be stored
// elsewhere from this `Module`. The returned bytes can, for example, be stored
// on disk or in an object store. The `NewModuleDeserialize` function can be
// used to deserialize the returned bytes at a later date to get the module
// back.
func (m *Module) Serialize() ([]byte, error) <span class="cov8" title="1">{
        retVec := C.wasm_byte_vec_t{}
        err := C.wasmtime_module_serialize(m.ptr(), &amp;retVec)
        runtime.KeepAlive(m)

        if err != nil </span><span class="cov0" title="0">{
                return nil, mkError(err)
        }</span>
        <span class="cov8" title="1">ret := C.GoBytes(unsafe.Pointer(retVec.data), C.int(retVec.size))
        C.wasm_byte_vec_delete(&amp;retVec)
        return ret, nil</span>
}

func (m *Module) AsExtern() *Extern <span class="cov8" title="1">{
        ptr := C.wasm_module_as_extern(m.ptr())
        return mkExtern(ptr, nil, m.owner())
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
import "C"
import "runtime"

// ModuleType describes the imports/exports of a module.
type ModuleType struct {
        _ptr   *C.wasm_moduletype_t
        _owner interface{}
}

func mkModuleType(ptr *C.wasm_moduletype_t, owner interface{}) *ModuleType <span class="cov8" title="1">{
        moduletype := &amp;ModuleType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(moduletype, func(moduletype *ModuleType) </span><span class="cov8" title="1">{
                        C.wasm_moduletype_delete(moduletype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return moduletype</span>
}

func (ty *ModuleType) ptr() *C.wasm_moduletype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *ModuleType) owner() interface{} <span class="cov0" title="0">{
        if ty._owner != nil </span><span class="cov0" title="0">{
                return ty._owner
        }</span>
        <span class="cov0" title="0">return ty</span>
}

// AsExternType converts this type to an instance of `ExternType`
func (ty *ModuleType) AsExternType() *ExternType <span class="cov0" title="0">{
        ptr := C.wasm_moduletype_as_externtype_const(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>

// Imports returns a list of `ImportType` items which are the items imported by
// this module and are required for instantiation.
func (m *ModuleType) Imports() []*ImportType <span class="cov8" title="1">{
        imports := &amp;importTypeList{}
        C.wasm_moduletype_imports(m.ptr(), &amp;imports.vec)
        runtime.KeepAlive(m)
        return imports.mkGoList()
}</span>

// Exports returns a list of `ExportType` items which are the items that will
// be exported by this module after instantiation.
func (m *ModuleType) Exports() []*ExportType <span class="cov8" title="1">{
        exports := &amp;exportTypeList{}
        C.wasm_moduletype_exports(m.ptr(), &amp;exports.vec)
        runtime.KeepAlive(m)
        return exports.mkGoList()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package wasmtime

type slab struct {
        list []int
        next int
}

func (s *slab) allocate() int <span class="cov8" title="1">{
        if s.next == len(s.list) </span><span class="cov8" title="1">{
                s.list = append(s.list, s.next+1)
        }</span>
        <span class="cov8" title="1">ret := s.next
        s.next = s.list[ret]
        return ret</span>
}

func (s *slab) deallocate(slot int) <span class="cov8" title="1">{
        s.list[slot] = s.next
        s.next = slot
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
// #include &lt;wasmtime.h&gt;
import "C"
import (
        "errors"
        "runtime"
)

// Store is a general group of wasm instances, and many objects
// must all be created with and reference the same `Store`
type Store struct {
        _ptr     *C.wasm_store_t
        freelist *freeList
        Engine   *Engine
}

// NewStore creates a new `Store` from the configuration provided in `engine`
func NewStore(engine *Engine) *Store <span class="cov8" title="1">{
        store := &amp;Store{
                _ptr:     C.wasm_store_new(engine.ptr()),
                freelist: newFreeList(),
                Engine:   engine,
        }
        runtime.KeepAlive(engine)
        runtime.SetFinalizer(store, func(store *Store) </span><span class="cov8" title="1">{
                freelist := store.freelist
                freelist.lock.Lock()
                defer freelist.lock.Unlock()
                freelist.stores = append(freelist.stores, store._ptr)
        }</span>)
        <span class="cov8" title="1">return store</span>
}

func (store *Store) InterruptHandle() (*InterruptHandle, error) <span class="cov8" title="1">{
        ptr := C.wasmtime_interrupt_handle_new(store.ptr())
        runtime.KeepAlive(store)
        if ptr == nil </span><span class="cov8" title="1">{
                return nil, errors.New("interrupts not enabled in `Config`")
        }</span>

        <span class="cov8" title="1">handle := &amp;InterruptHandle{_ptr: ptr}
        runtime.SetFinalizer(handle, func(handle *InterruptHandle) </span><span class="cov0" title="0">{
                C.wasmtime_interrupt_handle_delete(handle._ptr)
        }</span>)
        <span class="cov8" title="1">return handle, nil</span>
}

// GC will clean up any `externref` values that are no longer actually
// referenced.
//
// This function is not required to be called for correctness, it's only an
// optimization if desired to clean out any extra `externref` values.
func (store *Store) GC() <span class="cov8" title="1">{
        C.wasmtime_store_gc(store.ptr())
        runtime.KeepAlive(store)
}</span>

func (store *Store) ptr() *C.wasm_store_t <span class="cov8" title="1">{
        store.freelist.clear()
        ret := store._ptr
        maybeGC()
        return ret
}</span>

// InterruptHandle is used to interrupt the execution of currently running
// wasm code.
//
// For more information see
// https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Store.html#method.interrupt_handle
type InterruptHandle struct {
        _ptr *C.wasmtime_interrupt_handle_t
}

// Interrupt interrupts currently executing WebAssembly code, if it's currently running,
// or interrupts wasm the next time it starts running.
//
// For more information see
// https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Store.html#method.interrupt_handle
func (i *InterruptHandle) Interrupt() <span class="cov8" title="1">{
        C.wasmtime_interrupt_handle_interrupt(i.ptr())
        runtime.KeepAlive(i)
}</span>

func (i *InterruptHandle) ptr() *C.wasmtime_interrupt_handle_t <span class="cov8" title="1">{
        ret := i._ptr
        maybeGC()
        return ret
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
//
// wasm_ref_t *go_get_ref(wasm_val_t *val) { return val-&gt;of.ref; }
// void go_init_ref(wasm_val_t *val, wasm_ref_t *i) { val-&gt;of.ref = i; }
import "C"
import (
        "errors"
        "runtime"
)

// Table is a table instance, which is the runtime representation of a table.
//
// It holds a vector of reference types and an optional maximum size, if one was
// specified in the table type at the table’s definition site.
// Read more in [spec](https://webassembly.github.io/spec/core/exec/runtime.html#table-instances)
type Table struct {
        _ptr     *C.wasm_table_t
        _owner   interface{}
        freelist *freeList
}

// NewTable creates a new `Table` in the given `Store` with the specified `ty`.
//
// The `ty` must be a reference type (`funref` or `externref`) and `init`
// is the initial value for all table slots and must have the type specified by
// `ty`.
func NewTable(store *Store, ty *TableType, init Val) (*Table, error) <span class="cov8" title="1">{
        initPtr, err := getRefPtr(init)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ptr := C.wasm_table_new(store.ptr(), ty.ptr(), initPtr)
        runtime.KeepAlive(store)
        runtime.KeepAlive(ty)
        runtime.KeepAlive(init)
        if ptr == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to create table")
        }</span>
        <span class="cov8" title="1">return mkTable(ptr, store.freelist, nil), nil</span>
}

func mkTable(ptr *C.wasm_table_t, freelist *freeList, owner interface{}) *Table <span class="cov8" title="1">{
        f := &amp;Table{_ptr: ptr, _owner: owner, freelist: freelist}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(f, func(f *Table) </span><span class="cov8" title="1">{
                        f.freelist.lock.Lock()
                        defer f.freelist.lock.Unlock()
                        f.freelist.tables = append(f.freelist.tables, f._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return f</span>
}

func (t *Table) ptr() *C.wasm_table_t <span class="cov8" title="1">{
        ret := t._ptr
        maybeGC()
        return ret
}</span>

func (t *Table) owner() interface{} <span class="cov8" title="1">{
        if t._owner != nil </span><span class="cov8" title="1">{
                return t._owner
        }</span>
        <span class="cov0" title="0">return t</span>
}

// Size returns the size of this table in units of elements.
func (t *Table) Size() uint32 <span class="cov8" title="1">{
        ret := C.wasm_table_size(t.ptr())
        runtime.KeepAlive(t)
        return uint32(ret)
}</span>

// Grow grows this table by the number of units specified, using the
// specified initializer value for new slots.
//
// Returns an error if the table failed to grow, or the previous size of the
// table if growth was successful.
func (t *Table) Grow(delta uint32, init Val) (uint32, error) <span class="cov8" title="1">{
        if t.Type().Element().Kind() != init.Kind() </span><span class="cov0" title="0">{
                return 0, errors.New("wrong type of initializer passed to `Grow`")
        }</span>
        <span class="cov8" title="1">ptr, err := getRefPtr(init)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">ok := C.wasm_table_grow(t.ptr(), C.uint32_t(delta), ptr)
        runtime.KeepAlive(t)
        runtime.KeepAlive(init)
        if ok </span><span class="cov8" title="1">{
                return t.Size() - delta, nil
        }</span>

        <span class="cov0" title="0">return 0, errors.New("failed to grow table")</span>
}

func (t *Table) nullValue() Val <span class="cov8" title="1">{
        switch t.Type().Element().Kind() </span>{
        case KindFuncref:<span class="cov8" title="1">
                return ValFuncref(nil)</span>
        case KindExternref:<span class="cov8" title="1">
                return ValExternref(nil)</span>
        default:<span class="cov0" title="0">
                panic("unsupported table type")</span>
        }
}

// Get gets an item from this table from the specified index.
//
// Returns an error if the index is out of bounds, or returns a value (which
// may be internally null) if the index is in bounds corresponding to the entry
// at the specified index.
func (t *Table) Get(idx uint32) (Val, error) <span class="cov8" title="1">{
        null := t.nullValue()
        if idx &gt;= t.Size() </span><span class="cov8" title="1">{
                return null, errors.New("index out of bounds")
        }</span>
        <span class="cov8" title="1">valPtr := C.wasm_table_get(t.ptr(), C.uint32_t(idx))
        runtime.KeepAlive(t)
        if valPtr == nil </span><span class="cov8" title="1">{
                return null, nil
        }</span>
        <span class="cov8" title="1">C.go_init_ref(null.ptr(), valPtr)
        ret := takeVal(null.ptr(), t.freelist)
        runtime.KeepAlive(null)
        return ret, nil</span>
}

// Set sets an item in this table at the specified index.
//
// Returns an error if the index is out of bounds.
func (t *Table) Set(idx uint32, val Val) error <span class="cov8" title="1">{
        if t.Type().Element().Kind() != val.Kind() </span><span class="cov0" title="0">{
                return errors.New("wrong type of initializer passed to `Grow`")
        }</span>
        <span class="cov8" title="1">ptr, err := getRefPtr(val)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ok := C.wasm_table_set(t.ptr(), C.uint32_t(idx), ptr)
        runtime.KeepAlive(t)
        runtime.KeepAlive(val)
        if !ok </span><span class="cov8" title="1">{
                return errors.New("failed to set table index")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Type returns the underlying type of this table
func (t *Table) Type() *TableType <span class="cov8" title="1">{
        ptr := C.wasm_table_type(t.ptr())
        runtime.KeepAlive(t)
        return mkTableType(ptr, nil)
}</span>

func (t *Table) AsExtern() *Extern <span class="cov8" title="1">{
        ptr := C.wasm_table_as_extern(t.ptr())
        return mkExtern(ptr, t.freelist, t.owner())
}</span>

func getRefPtr(val Val) (*C.wasm_ref_t, error) <span class="cov8" title="1">{
        switch val.Kind() </span>{
        case KindExternref, KindFuncref:<span class="cov8" title="1">
                return C.go_get_ref(val.ptr()), nil</span>
        }
        <span class="cov0" title="0">return nil, errors.New("not a reference type")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// TableType is one of table types which classify tables over elements of element types within a size range.
type TableType struct {
        _ptr   *C.wasm_tabletype_t
        _owner interface{}
}

// NewTableType creates a new `TableType` with the `element` type provided as well as
// `limits` on its size.
func NewTableType(element *ValType, limits Limits) *TableType <span class="cov8" title="1">{
        valptr := C.wasm_valtype_new(C.wasm_valtype_kind(element.ptr()))
        runtime.KeepAlive(element)
        limitsFFI := limits.ffi()
        ptr := C.wasm_tabletype_new(valptr, &amp;limitsFFI)

        return mkTableType(ptr, nil)
}</span>

func mkTableType(ptr *C.wasm_tabletype_t, owner interface{}) *TableType <span class="cov8" title="1">{
        tabletype := &amp;TableType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(tabletype, func(tabletype *TableType) </span><span class="cov8" title="1">{
                        C.wasm_tabletype_delete(tabletype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return tabletype</span>
}

func (ty *TableType) ptr() *C.wasm_tabletype_t <span class="cov8" title="1">{
        ret := ty._ptr
        maybeGC()
        return ret
}</span>

func (ty *TableType) owner() interface{} <span class="cov8" title="1">{
        if ty._owner != nil </span><span class="cov8" title="1">{
                return ty._owner
        }</span>
        <span class="cov8" title="1">return ty</span>
}

// Element returns the type of value stored in this table
func (ty *TableType) Element() *ValType <span class="cov8" title="1">{
        ptr := C.wasm_tabletype_element(ty.ptr())
        return mkValType(ptr, ty.owner())
}</span>

// Limits returns limits on the size of this table type
func (ty *TableType) Limits() Limits <span class="cov8" title="1">{
        ptr := C.wasm_tabletype_limits(ty.ptr())
        return mkLimits(ptr, ty.owner())
}</span>

// AsExternType converts this type to an instance of `ExternType`
func (ty *TableType) AsExternType() *ExternType <span class="cov8" title="1">{
        ptr := C.wasm_tabletype_as_externtype_const(ty.ptr())
        return mkExternType(ptr, ty.owner())
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package wasmtime

// #include &lt;stdlib.h&gt;
// #include &lt;wasm.h&gt;
// #include &lt;wasmtime.h&gt;
import "C"

import (
        "runtime"
        "unsafe"
)

// Trap is the trap instruction which represents the occurrence of a trap.
// Traps are bubbled up through nested instruction sequences, ultimately reducing the entire program to a single trap instruction, signalling abrupt termination.
type Trap struct {
        _ptr *C.wasm_trap_t
}

// Frame is one of activation frames which carry the return arity n of the respective function,
// hold the values of its locals (including arguments) in the order corresponding to their static local indices,
// and a reference to the function’s own module instance
type Frame struct {
        _ptr   *C.wasm_frame_t
        _owner interface{}
}

// NewTrap creates a new `Trap` with the `name` and the type provided.
func NewTrap(store *Store, message string) *Trap <span class="cov8" title="1">{
        cs := C.CString(message)
        messageVec := C.wasm_byte_vec_t{
                data: cs,
                size: C.size_t(len(message) + 1),
        }
        ptr := C.wasm_trap_new(store.ptr(), &amp;messageVec)
        C.free(unsafe.Pointer(cs))
        runtime.KeepAlive(store)
        return mkTrap(ptr)
}</span>

func mkTrap(ptr *C.wasm_trap_t) *Trap <span class="cov8" title="1">{
        trap := &amp;Trap{_ptr: ptr}
        runtime.SetFinalizer(trap, func(trap *Trap) </span><span class="cov8" title="1">{
                C.wasm_trap_delete(trap._ptr)
        }</span>)
        <span class="cov8" title="1">return trap</span>
}

func (t *Trap) ptr() *C.wasm_trap_t <span class="cov8" title="1">{
        ret := t._ptr
        maybeGC()
        return ret
}</span>

// Message returns the name in the module this export type is exporting
func (t *Trap) Message() string <span class="cov8" title="1">{
        message := C.wasm_byte_vec_t{}
        C.wasm_trap_message(t.ptr(), &amp;message)
        ret := C.GoStringN(message.data, C.int(message.size-1))
        runtime.KeepAlive(t)
        C.wasm_byte_vec_delete(&amp;message)
        return ret
}</span>

func (t *Trap) Error() string <span class="cov8" title="1">{
        return t.Message()
}</span>

func unwrapStrOr(s *string, other string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return other
        }</span>

        <span class="cov0" title="0">return *s</span>
}

type frameList struct {
        vec C.wasm_frame_vec_t
}

// Frames returns the wasm function frames that make up this trap
func (t *Trap) Frames() []*Frame <span class="cov8" title="1">{
        frames := &amp;frameList{}
        C.wasm_trap_trace(t.ptr(), &amp;frames.vec)
        runtime.KeepAlive(t)
        runtime.SetFinalizer(frames, func(frames *frameList) </span><span class="cov0" title="0">{
                C.wasm_frame_vec_delete(&amp;frames.vec)
        }</span>)

        <span class="cov8" title="1">ret := make([]*Frame, int(frames.vec.size))
        base := unsafe.Pointer(frames.vec.data)
        var ptr *C.wasm_frame_t
        for i := 0; i &lt; int(frames.vec.size); i++ </span><span class="cov8" title="1">{
                ptr := *(**C.wasm_frame_t)(unsafe.Pointer(uintptr(base) + unsafe.Sizeof(ptr)*uintptr(i)))
                ret[i] = &amp;Frame{
                        _ptr:   ptr,
                        _owner: frames,
                }
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (f *Frame) ptr() *C.wasm_frame_t <span class="cov8" title="1">{
        ret := f._ptr
        maybeGC()
        return ret
}</span>

// FuncIndex returns the function index in the wasm module that this frame represents
func (f *Frame) FuncIndex() uint32 <span class="cov8" title="1">{
        ret := C.wasm_frame_func_index(f.ptr())
        runtime.KeepAlive(f)
        return uint32(ret)
}</span>

// FuncName returns the name, if available, for this frame's function
func (f *Frame) FuncName() *string <span class="cov8" title="1">{
        ret := C.wasmtime_frame_func_name(f.ptr())
        if ret == nil </span><span class="cov8" title="1">{
                runtime.KeepAlive(f)
                return nil
        }</span>
        <span class="cov8" title="1">str := C.GoStringN(ret.data, C.int(ret.size))
        runtime.KeepAlive(f)
        return &amp;str</span>
}

// ModuleName returns the name, if available, for this frame's module
func (f *Frame) ModuleName() *string <span class="cov8" title="1">{
        ret := C.wasmtime_frame_module_name(f.ptr())
        if ret == nil </span><span class="cov0" title="0">{
                runtime.KeepAlive(f)
                return nil
        }</span>
        <span class="cov8" title="1">str := C.GoStringN(ret.data, C.int(ret.size))
        runtime.KeepAlive(f)
        return &amp;str</span>
}

// ModuleOffset returns offset of this frame's instruction into the original module
func (f *Frame) ModuleOffset() uint <span class="cov0" title="0">{
        ret := uint(C.wasm_frame_module_offset(f.ptr()))
        runtime.KeepAlive(f)
        return ret
}</span>

// FuncOffset returns offset of this frame's instruction into the original function
func (f *Frame) FuncOffset() uint <span class="cov0" title="0">{
        ret := uint(C.wasm_frame_func_offset(f.ptr()))
        runtime.KeepAlive(f)
        return ret
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
// #include "shims.h"
import "C"
import (
        "runtime"
        "sync"
        "unsafe"
)

var gExternrefLock sync.Mutex
var gExternrefMap = make(map[int]interface{})
var gExternrefSlab slab

// Val is a primitive numeric value.
// Moreover, in the definition of programs, immutable sequences of values occur to represent more complex data, such as text strings or other vectors.
type Val struct {
        _raw     *C.wasm_val_t
        freelist *freeList
}

// ValI32 converts a go int32 to a i32 Val
func ValI32(val int32) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{kind: C.WASM_I32}}
        C.go_init_i32(ret.ptr(), C.int32_t(val))
        return ret
}</span>

// ValI64 converts a go int64 to a i64 Val
func ValI64(val int64) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{kind: C.WASM_I64}}
        C.go_init_i64(ret.ptr(), C.int64_t(val))
        return ret
}</span>

// ValF32 converts a go float32 to a f32 Val
func ValF32(val float32) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{kind: C.WASM_F32}}
        C.go_init_f32(ret.ptr(), C.float(val))
        return ret
}</span>

// ValF64 converts a go float64 to a f64 Val
func ValF64(val float64) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{kind: C.WASM_F64}}
        C.go_init_f64(ret.ptr(), C.double(val))
        return ret
}</span>

// ValFuncref converts a Func to a funcref Val
//
// Note that `f` can be `nil` to represent a null `funcref`.
func ValFuncref(f *Func) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{kind: C.WASM_FUNCREF}}
        if f != nil </span><span class="cov8" title="1">{
                ret.freelist = f.freelist
                C.wasmtime_func_as_funcref(f.ptr(), ret.ptr())
                runtime.KeepAlive(f)
                ret.setDtor()
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// ValExternref converts a go value to a externref Val
//
// Using `externref` is a way to pass arbitrary Go data into a WebAssembly
// module for it to store. Later, when you get a `Val`, you can extract the type
// with the `Externref()` method.
func ValExternref(val interface{}) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{kind: C.WASM_ANYREF}}

        // If we have a non-nil value then store it in our global map of all
        // externref values. Otherwise there's nothing for us to do since the
        // `ref` field will already be a nil pointer.
        //
        // Note that we add 1 so all non-null externref values are created with
        // non-null pointers.
        if val != nil </span><span class="cov8" title="1">{
                gExternrefLock.Lock()
                defer gExternrefLock.Unlock()
                index := gExternrefSlab.allocate()
                gExternrefMap[index] = val
                C.go_externref_new_with_finalizer(C.size_t(index+1), ret.ptr())
                ret.setDtor()
        }</span>
        <span class="cov8" title="1">return ret</span>
}

//export goFinalizeExternref
func goFinalizeExternref(env unsafe.Pointer) <span class="cov8" title="1">{
        idx := int(uintptr(env)) - 1
        gExternrefLock.Lock()
        defer gExternrefLock.Unlock()
        delete(gExternrefMap, idx)
        gExternrefSlab.deallocate(idx)
}</span>

func mkVal(src *C.wasm_val_t, freelist *freeList) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{}, freelist: freelist}
        C.wasm_val_copy(ret.ptr(), src)
        ret.setDtor()
        return ret
}</span>

func takeVal(src *C.wasm_val_t, freelist *freeList) Val <span class="cov8" title="1">{
        ret := Val{_raw: &amp;C.wasm_val_t{}, freelist: freelist}
        *ret.ptr() = *src
        ret.setDtor()
        return ret
}</span>

func (v Val) setDtor() <span class="cov8" title="1">{
        freelist := v.freelist
        if v.Kind() == KindFuncref &amp;&amp; freelist == nil </span><span class="cov0" title="0">{
                panic("freelist not set")</span>
        }
        // If we're deleting a funcref, that needs to happen on the thread with
        // the original `Store`. Otherwise we can delete values on any thread,
        // such as externrefs.
        <span class="cov8" title="1">runtime.SetFinalizer(v.ptr(), func(ptr *C.wasm_val_t) </span><span class="cov8" title="1">{
                if ptr.kind == C.WASM_FUNCREF </span><span class="cov8" title="1">{
                        freelist.lock.Lock()
                        defer freelist.lock.Unlock()
                        freelist.vals = append(freelist.vals, ptr)
                }</span> else<span class="cov8" title="1"> {
                        C.wasm_val_delete(ptr)
                }</span>
        })
}

func (v Val) ptr() *C.wasm_val_t <span class="cov8" title="1">{
        ret := v._raw
        maybeGC()
        return ret
}</span>

// Kind returns the kind of value that this `Val` contains.
func (v Val) Kind() ValKind <span class="cov8" title="1">{
        return ValKind(v.ptr().kind)
}</span>

// I32 returns the underlying 32-bit integer if this is an `i32`, or panics.
func (v Val) I32() int32 <span class="cov8" title="1">{
        if v.Kind() != KindI32 </span><span class="cov0" title="0">{
                panic("not an i32")</span>
        }
        <span class="cov8" title="1">return int32(C.go_get_i32(v.ptr()))</span>
}

// I64 returns the underlying 64-bit integer if this is an `i64`, or panics.
func (v Val) I64() int64 <span class="cov8" title="1">{
        if v.Kind() != KindI64 </span><span class="cov0" title="0">{
                panic("not an i64")</span>
        }
        <span class="cov8" title="1">return int64(C.go_get_i64(v.ptr()))</span>
}

// F32 returns the underlying 32-bit float if this is an `f32`, or panics.
func (v Val) F32() float32 <span class="cov8" title="1">{
        if v.Kind() != KindF32 </span><span class="cov0" title="0">{
                panic("not an f32")</span>
        }
        <span class="cov8" title="1">return float32(C.go_get_f32(v.ptr()))</span>
}

// F64 returns the underlying 64-bit float if this is an `f64`, or panics.
func (v Val) F64() float64 <span class="cov8" title="1">{
        if v.Kind() != KindF64 </span><span class="cov0" title="0">{
                panic("not an f64")</span>
        }
        <span class="cov8" title="1">return float64(C.go_get_f64(v.ptr()))</span>
}

// Funcref returns the underlying function if this is a `funcref`, or panics.
//
// Note that a null `funcref` is returned as `nil`.
func (v Val) Funcref() *Func <span class="cov8" title="1">{
        if v.Kind() != KindFuncref </span><span class="cov0" title="0">{
                panic("not a funcref")</span>
        }
        <span class="cov8" title="1">ptr := C.wasmtime_funcref_as_func(v.ptr())
        runtime.KeepAlive(v)
        if ptr != nil </span><span class="cov8" title="1">{
                if v.freelist == nil </span><span class="cov0" title="0">{
                        panic("freelist not available")</span>
                }
                <span class="cov8" title="1">return mkFunc(ptr, v.freelist, nil)</span>
        } else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// Externref returns the underlying value if this is an `externref`, or panics.
//
// Note that a null `externref` is returned as `nil`.
func (v Val) Externref() interface{} <span class="cov8" title="1">{
        var data unsafe.Pointer
        ok := C.wasmtime_externref_data(v.ptr(), &amp;data)
        runtime.KeepAlive(v)
        if !ok </span><span class="cov0" title="0">{
                panic("not an externref")</span>
        }
        <span class="cov8" title="1">if data == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">gExternrefLock.Lock()
        defer gExternrefLock.Unlock()
        return gExternrefMap[int(uintptr(data))-1]</span>
}

// Get returns the underlying 64-bit float if this is an `f64`, or panics.
func (v Val) Get() interface{} <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case KindI32:<span class="cov8" title="1">
                return v.I32()</span>
        case KindI64:<span class="cov8" title="1">
                return v.I64()</span>
        case KindF32:<span class="cov8" title="1">
                return v.F32()</span>
        case KindF64:<span class="cov8" title="1">
                return v.F64()</span>
        case KindFuncref:<span class="cov8" title="1">
                return v.Funcref()</span>
        case KindExternref:<span class="cov8" title="1">
                return v.Externref()</span>
        }
        <span class="cov0" title="0">panic("failed to get value of `Val`")</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package wasmtime

// #include &lt;wasm.h&gt;
import "C"
import "runtime"

// ValKind enumeration of different kinds of value types
type ValKind C.wasm_valkind_t

const (
        // KindI32 is the types i32 classify 32 bit integers. Integers are not inherently signed or unsigned, their interpretation is determined by individual operations.
        KindI32 ValKind = C.WASM_I32
        // KindI64 is the types i64 classify 64 bit integers. Integers are not inherently signed or unsigned, their interpretation is determined by individual operations.
        KindI64 ValKind = C.WASM_I64
        // KindF32 is the types f32 classify 32 bit floating-point data. They correspond to the respective binary floating-point representations, also known as single and double precision, as defined by the IEEE 754-2019 standard.
        KindF32 ValKind = C.WASM_F32
        // KindF64 is the types f64 classify 64 bit floating-point data. They correspond to the respective binary floating-point representations, also known as single and double precision, as defined by the IEEE 754-2019 standard.
        KindF64 ValKind = C.WASM_F64
        // TODO: Unknown
        KindExternref ValKind = C.WASM_ANYREF
        // KindFuncref is the infinite union of all function types.
        KindFuncref ValKind = C.WASM_FUNCREF
)

// String renders this kind as a string, similar to the `*.wat` format
func (ty ValKind) String() string <span class="cov0" title="0">{
        switch ty </span>{
        case KindI32:<span class="cov0" title="0">
                return "i32"</span>
        case KindI64:<span class="cov0" title="0">
                return "i64"</span>
        case KindF32:<span class="cov0" title="0">
                return "f32"</span>
        case KindF64:<span class="cov0" title="0">
                return "f64"</span>
        case KindExternref:<span class="cov0" title="0">
                return "externref"</span>
        case KindFuncref:<span class="cov0" title="0">
                return "funcref"</span>
        }
        <span class="cov0" title="0">panic("unknown kind")</span>
}

// ValType means one of the value types, which classify the individual values that WebAssembly code can compute with and the values that a variable accepts.
type ValType struct {
        _ptr   *C.wasm_valtype_t
        _owner interface{}
}

// NewValType creates a new `ValType` with the `kind` provided
func NewValType(kind ValKind) *ValType <span class="cov8" title="1">{
        ptr := C.wasm_valtype_new(C.wasm_valkind_t(kind))
        return mkValType(ptr, nil)
}</span>

func mkValType(ptr *C.wasm_valtype_t, owner interface{}) *ValType <span class="cov8" title="1">{
        valtype := &amp;ValType{_ptr: ptr, _owner: owner}
        if owner == nil </span><span class="cov8" title="1">{
                runtime.SetFinalizer(valtype, func(valtype *ValType) </span><span class="cov8" title="1">{
                        C.wasm_valtype_delete(valtype._ptr)
                }</span>)
        }
        <span class="cov8" title="1">return valtype</span>
}

// Kind returns the corresponding `ValKind` for this `ValType`
func (t *ValType) Kind() ValKind <span class="cov8" title="1">{
        ret := ValKind(C.wasm_valtype_kind(t.ptr()))
        runtime.KeepAlive(t)
        return ret
}</span>

// Converts this `ValType` into a string according to the string representation
// of `ValKind`.
func (t *ValType) String() string <span class="cov0" title="0">{
        return t.Kind().String()
}</span>

func (t *ValType) ptr() *C.wasm_valtype_t <span class="cov8" title="1">{
        ret := t._ptr
        maybeGC()
        return ret
}</span>

func (t *ValType) owner() interface{} <span class="cov0" title="0">{
        if t._owner != nil </span><span class="cov0" title="0">{
                return t._owner
        }</span>
        <span class="cov0" title="0">return t</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package wasmtime

// #include &lt;wasi.h&gt;
// #include &lt;stdlib.h&gt;
import "C"
import (
        "errors"
        "runtime"
        "unsafe"
)

type WasiConfig struct {
        _ptr *C.wasi_config_t
}

func NewWasiConfig() *WasiConfig <span class="cov8" title="1">{
        ptr := C.wasi_config_new()
        config := &amp;WasiConfig{_ptr: ptr}
        runtime.SetFinalizer(config, func(config *WasiConfig) </span><span class="cov0" title="0">{
                C.wasi_config_delete(config._ptr)
        }</span>)
        <span class="cov8" title="1">return config</span>
}

func (c *WasiConfig) ptr() *C.wasi_config_t <span class="cov8" title="1">{
        ret := c._ptr
        maybeGC()
        return ret
}</span>

// SetArgv will explicitly configure the argv for this WASI configuration.
// Note that this field can only be set, it cannot be read
func (c *WasiConfig) SetArgv(argv []string) <span class="cov0" title="0">{
        ptrs := make([]*C.char, len(argv))
        for i, arg := range argv </span><span class="cov0" title="0">{
                ptrs[i] = C.CString(arg)
        }</span>
        <span class="cov0" title="0">var argvRaw **C.char
        if len(ptrs) &gt; 0 </span><span class="cov0" title="0">{
                argvRaw = &amp;ptrs[0]
        }</span>
        <span class="cov0" title="0">C.wasi_config_set_argv(c.ptr(), C.int(len(argv)), argvRaw)
        runtime.KeepAlive(c)
        for _, ptr := range ptrs </span><span class="cov0" title="0">{
                C.free(unsafe.Pointer(ptr))
        }</span>
}

func (c *WasiConfig) InheritArgv() <span class="cov0" title="0">{
        C.wasi_config_inherit_argv(c.ptr())
        runtime.KeepAlive(c)
}</span>

// SetEnv configures environment variables to be returned for this WASI configuration.
// The pairs provided must be an iterable list of key/value pairs of environment variables.
// Note that this field can only be set, it cannot be read
func (c *WasiConfig) SetEnv(keys, values []string) <span class="cov8" title="1">{
        if len(keys) != len(values) </span><span class="cov0" title="0">{
                panic("mismatched numbers of keys and values")</span>
        }
        <span class="cov8" title="1">namePtrs := make([]*C.char, len(values))
        valuePtrs := make([]*C.char, len(values))
        for i, key := range keys </span><span class="cov8" title="1">{
                namePtrs[i] = C.CString(key)
        }</span>
        <span class="cov8" title="1">for i, value := range values </span><span class="cov8" title="1">{
                valuePtrs[i] = C.CString(value)
        }</span>
        <span class="cov8" title="1">var namesRaw, valuesRaw **C.char
        if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                namesRaw = &amp;namePtrs[0]
                valuesRaw = &amp;valuePtrs[0]
        }</span>
        <span class="cov8" title="1">C.wasi_config_set_env(c.ptr(), C.int(len(keys)), namesRaw, valuesRaw)
        runtime.KeepAlive(c)
        for i, ptr := range namePtrs </span><span class="cov8" title="1">{
                C.free(unsafe.Pointer(ptr))
                C.free(unsafe.Pointer(valuePtrs[i]))
        }</span>
}

func (c *WasiConfig) InheritEnv() <span class="cov0" title="0">{
        C.wasi_config_inherit_env(c.ptr())
        runtime.KeepAlive(c)
}</span>

func (c *WasiConfig) SetStdinFile(path string) error <span class="cov0" title="0">{
        pathC := C.CString(path)
        ok := C.wasi_config_set_stdin_file(c.ptr(), pathC)
        runtime.KeepAlive(c)
        C.free(unsafe.Pointer(pathC))
        if ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.New("failed to open file")</span>
}

func (c *WasiConfig) InheritStdin() <span class="cov0" title="0">{
        C.wasi_config_inherit_stdin(c.ptr())
        runtime.KeepAlive(c)
}</span>

func (c *WasiConfig) SetStdoutFile(path string) error <span class="cov8" title="1">{
        pathC := C.CString(path)
        ok := C.wasi_config_set_stdout_file(c.ptr(), pathC)
        runtime.KeepAlive(c)
        C.free(unsafe.Pointer(pathC))
        if ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.New("failed to open file")</span>
}

func (c *WasiConfig) InheritStdout() <span class="cov0" title="0">{
        C.wasi_config_inherit_stdout(c.ptr())
        runtime.KeepAlive(c)
}</span>

func (c *WasiConfig) SetStderrFile(path string) error <span class="cov0" title="0">{
        pathC := C.CString(path)
        ok := C.wasi_config_set_stderr_file(c.ptr(), pathC)
        runtime.KeepAlive(c)
        C.free(unsafe.Pointer(pathC))
        if ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.New("failed to open file")</span>
}

func (c *WasiConfig) InheritStderr() <span class="cov0" title="0">{
        C.wasi_config_inherit_stderr(c.ptr())
        runtime.KeepAlive(c)
}</span>

func (c *WasiConfig) PreopenDir(path, guestPath string) error <span class="cov0" title="0">{
        pathC := C.CString(path)
        guestPathC := C.CString(guestPath)
        ok := C.wasi_config_preopen_dir(c.ptr(), pathC, guestPathC)
        runtime.KeepAlive(c)
        C.free(unsafe.Pointer(pathC))
        C.free(unsafe.Pointer(guestPathC))
        if ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.New("failed to preopen directory")</span>
}

type WasiInstance struct {
        _ptr     *C.wasi_instance_t
        freelist *freeList
}

// NewWasiInstance creates a new instance of WASI with the given configuration.
//
// The version of WASI must be explicitly requested via `name`.
func NewWasiInstance(store *Store, config *WasiConfig, name string) (*WasiInstance, error) <span class="cov8" title="1">{
        if config._ptr == nil </span><span class="cov0" title="0">{
                panic("config already used to create wasi instance")</span>
        }
        <span class="cov8" title="1">var trap *C.wasm_trap_t
        namePtr := C.CString(name)
        ptr := C.wasi_instance_new(
                store.ptr(),
                namePtr,
                config.ptr(),
                &amp;trap,
        )
        runtime.KeepAlive(store)
        config._ptr = nil
        runtime.SetFinalizer(config, nil)
        C.free(unsafe.Pointer(namePtr))

        if ptr == nil </span><span class="cov8" title="1">{
                if trap != nil </span><span class="cov8" title="1">{
                        return nil, mkTrap(trap)
                }</span>
                <span class="cov0" title="0">return nil, errors.New("failed to create instance")</span>
        }

        <span class="cov8" title="1">instance := &amp;WasiInstance{
                _ptr:     ptr,
                freelist: store.freelist,
        }
        runtime.SetFinalizer(instance, func(instance *WasiInstance) </span><span class="cov0" title="0">{
                freelist := instance.freelist
                freelist.lock.Lock()
                defer freelist.lock.Unlock()
                freelist.wasiInstances = append(freelist.wasiInstances, instance._ptr)
        }</span>)
        <span class="cov8" title="1">return instance, nil</span>
}

func (i *WasiInstance) ptr() *C.wasi_instance_t <span class="cov8" title="1">{
        ret := i._ptr
        maybeGC()
        return ret
}</span>

// BindImport attempts to bind the `imp` import provided, returning an Extern suitable for
// satisfying the import if one can be found.
//
// If `imp` isn't defined by this instance of WASI then `nil` is returned.
func (i *WasiInstance) BindImport(imp *ImportType) *Extern <span class="cov0" title="0">{
        ret := C.wasi_instance_bind_import(i.ptr(), imp.ptr())
        runtime.KeepAlive(i)
        runtime.KeepAlive(imp)
        if ret == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return mkExtern(ret, i.freelist, nil)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package wasmtime

// #include &lt;wasmtime.h&gt;
//
// wasmtime_error_t *go_wat2wasm(
//  char *wat_ptr,
//  size_t wat_len,
//  wasm_byte_vec_t *ret
// ) {
//   wasm_byte_vec_t wat;
//   wat.data = wat_ptr;
//   wat.size = wat_len;
//   return wasmtime_wat2wasm(&amp;wat, ret);
// }
import "C"
import (
        "runtime"
        "unsafe"
)

// Wat2Wasm converts the text format of WebAssembly to the binary format.
//
// Takes the text format in-memory as input, and returns either the binary
// encoding of the text format or an error if parsing fails.
func Wat2Wasm(wat string) ([]byte, error) <span class="cov8" title="1">{
        retVec := C.wasm_byte_vec_t{}
        err := C.go_wat2wasm(
                C._GoStringPtr(wat),
                C._GoStringLen(wat),
                &amp;retVec,
        )
        runtime.KeepAlive(wat)

        if err == nil </span><span class="cov8" title="1">{
                ret := C.GoBytes(unsafe.Pointer(retVec.data), C.int(retVec.size))
                C.wasm_byte_vec_delete(&amp;retVec)
                return ret, nil
        }</span>

        <span class="cov8" title="1">return nil, mkError(err)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
